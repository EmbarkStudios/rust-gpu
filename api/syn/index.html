<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="github crates-io docs-rs"><title>syn - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-47e7ab555ef2818a.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="syn" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.0-nightly (4e78abb43 2023-08-28)" data-channel="nightly" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-f194925aa375ae96.css" data-theme-dark-css="dark-1dd4d1ce031e15de.css" data-theme-ayu-css="ayu-49e58d069f567085.css" ><script src="../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-ef3a2de404864b0b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-f194925aa375ae96.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1dd4d1ce031e15de.css"><link rel="stylesheet" href="../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../syn/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../syn/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate syn</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 1.0.105</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">syn</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/syn/lib.rs.html#1-984">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><a href="https://github.com/dtolnay/syn"><img src="https://img.shields.io/badge/github-8da0cb?style=for-the-badge&amp;labelColor=555555&amp;logo=github" alt="github" /></a> <a href="https://crates.io/crates/syn"><img src="https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&amp;labelColor=555555&amp;logo=rust" alt="crates-io" /></a> <a href="index.html" title="mod syn"><img src="https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&amp;labelColor=555555&amp;logo=docs.rs" alt="docs-rs" /></a></p>
<br>
<p>Syn is a parsing library for parsing a stream of Rust tokens into a syntax
tree of Rust source code.</p>
<p>Currently this library is geared toward use in Rust procedural macros, but
contains some APIs that may be useful more generally.</p>
<ul>
<li>
<p><strong>Data structures</strong> — Syn provides a complete syntax tree that can
represent any valid Rust source code. The syntax tree is rooted at
<a href="struct.File.html" title="struct syn::File"><code>syn::File</code></a> which represents a full source file, but there are other
entry points that may be useful to procedural macros including
<a href="enum.Item.html" title="enum syn::Item"><code>syn::Item</code></a>, <a href="enum.Expr.html" title="enum syn::Expr"><code>syn::Expr</code></a> and <a href="enum.Type.html" title="enum syn::Type"><code>syn::Type</code></a>.</p>
</li>
<li>
<p><strong>Derives</strong> — Of particular interest to derive macros is
<a href="struct.DeriveInput.html" title="struct syn::DeriveInput"><code>syn::DeriveInput</code></a> which is any of the three legal input items to a
derive macro. An example below shows using this type in a library that can
derive implementations of a user-defined trait.</p>
</li>
<li>
<p><strong>Parsing</strong> — Parsing in Syn is built around <a href="parse/index.html" title="mod syn::parse">parser functions</a> with the
signature <code>fn(ParseStream) -&gt; Result&lt;T&gt;</code>. Every syntax tree node defined
by Syn is individually parsable and may be used as a building block for
custom syntaxes, or you may dream up your own brand new syntax without
involving any of our syntax tree types.</p>
</li>
<li>
<p><strong>Location information</strong> — Every token parsed by Syn is associated with a
<code>Span</code> that tracks line and column information back to the source of that
token. These spans allow a procedural macro to display detailed error
messages pointing to all the right places in the user’s code. There is an
example of this below.</p>
</li>
<li>
<p><strong>Feature flags</strong> — Functionality is aggressively feature gated so your
procedural macros enable only what they need, and do not pay in compile
time for all the rest.</p>
</li>
</ul>
<br>
<h2 id="example-of-a-derive-macro"><a href="#example-of-a-derive-macro">Example of a derive macro</a></h2>
<p>The canonical derive macro using Syn looks like this. We write an ordinary
Rust function tagged with a <code>proc_macro_derive</code> attribute and the name of
the trait we are deriving. Any time that derive appears in the user’s code,
the Rust compiler passes their data structure as tokens into our macro. We
get to execute arbitrary Rust code to figure out what to do with those
tokens, then hand some tokens back to the compiler to compile into the
user’s crate.</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
syn = &quot;1.0&quot;
quote = &quot;1.0&quot;

[lib]
proc-macro = true
</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proc_macro::TokenStream;
<span class="kw">use </span>quote::quote;
<span class="kw">use </span>syn::{parse_macro_input, DeriveInput};

<span class="attr">#[proc_macro_derive(MyMacro)]
</span><span class="kw">pub fn </span>my_macro(input: TokenStream) -&gt; TokenStream {
    <span class="comment">// Parse the input tokens into a syntax tree
    </span><span class="kw">let </span>input = <span class="macro">parse_macro_input!</span>(input <span class="kw">as </span>DeriveInput);

    <span class="comment">// Build the output, possibly using quasi-quotation
    </span><span class="kw">let </span>expanded = <span class="macro">quote! </span>{
        <span class="comment">// ...
    </span>};

    <span class="comment">// Hand the output tokens back to the compiler
    </span>TokenStream::from(expanded)
}</code></pre></div>
<p>The <a href="https://github.com/dtolnay/syn/tree/master/examples/heapsize"><code>heapsize</code></a> example directory shows a complete working implementation
of a derive macro. It works on any Rust compiler 1.31+. The example derives
a <code>HeapSize</code> trait which computes an estimate of the amount of heap memory
owned by a value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub trait </span>HeapSize {
    <span class="doccomment">/// Total number of bytes of heap memory owned by `self`.
    </span><span class="kw">fn </span>heap_size_of_children(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize;
}</code></pre></div>
<p>The derive macro allows users to write <code>#[derive(HeapSize)]</code> on data
structures in their program.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(HeapSize)]
</span><span class="kw">struct </span>Demo&lt;<span class="lifetime">&#39;a</span>, T: <span class="question-mark">?</span>Sized&gt; {
    a: Box&lt;T&gt;,
    b: u8,
    c: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
    d: String,
}</code></pre></div>
<p><br></p>
<h2 id="spans-and-error-reporting"><a href="#spans-and-error-reporting">Spans and error reporting</a></h2>
<p>The token-based procedural macro API provides great control over where the
compiler’s error messages are displayed in user code. Consider the error the
user sees if one of their field types does not implement <code>HeapSize</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(HeapSize)]
</span><span class="kw">struct </span>Broken {
    ok: String,
    bad: std::thread::Thread,
}</code></pre></div>
<p>By tracking span information all the way through the expansion of a
procedural macro as shown in the <code>heapsize</code> example, token-based macros in
Syn are able to trigger errors that directly pinpoint the source of the
problem.</p>
<div class="example-wrap"><pre class="language-text"><code>error[E0277]: the trait bound `std::thread::Thread: HeapSize` is not satisfied
 --&gt; src/main.rs:7:5
  |
7 |     bad: std::thread::Thread,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `HeapSize` is not implemented for `Thread`
</code></pre></div><br>
<h2 id="parsing-a-custom-syntax"><a href="#parsing-a-custom-syntax">Parsing a custom syntax</a></h2>
<p>The <a href="https://github.com/dtolnay/syn/tree/master/examples/lazy-static"><code>lazy-static</code></a> example directory shows the implementation of a
<code>functionlike!(...)</code> procedural macro in which the input tokens are parsed
using Syn’s parsing API.</p>
<p>The example reimplements the popular <code>lazy_static</code> crate from crates.io as a
procedural macro.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">lazy_static! </span>{
    <span class="kw">static </span><span class="kw-2">ref </span>USERNAME: Regex = Regex::new(<span class="string">&quot;^[a-z0-9_-]{3,16}$&quot;</span>).unwrap();
}</code></pre></div>
<p>The implementation shows how to trigger custom warnings and error messages
on the macro input.</p>
<div class="example-wrap"><pre class="language-text"><code>warning: come on, pick a more creative name
  --&gt; src/main.rs:10:16
   |
10 |     static ref FOO: String = &quot;lazy_static&quot;.to_owned();
   |                ^^^
</code></pre></div><br>
<h2 id="testing"><a href="#testing">Testing</a></h2>
<p>When testing macros, we often care not just that the macro can be used
successfully but also that when the macro is provided with invalid input it
produces maximally helpful error messages. Consider using the <a href="https://github.com/dtolnay/trybuild"><code>trybuild</code></a>
crate to write tests for errors that are emitted by your macro or errors
detected by the Rust compiler in the expanded code following misuse of the
macro. Such tests help avoid regressions from later refactors that
mistakenly make an error no longer trigger or be less helpful than it used
to be.</p>
<br>
<h2 id="debugging"><a href="#debugging">Debugging</a></h2>
<p>When developing a procedural macro it can be helpful to look at what the
generated code looks like. Use <code>cargo rustc -- -Zunstable-options --pretty=expanded</code> or the <a href="https://github.com/dtolnay/cargo-expand"><code>cargo expand</code></a> subcommand.</p>
<p>To show the expanded code for some crate that uses your procedural macro,
run <code>cargo expand</code> from that crate. To show the expanded code for one of
your own test cases, run <code>cargo expand --test the_test_case</code> where the last
argument is the name of the test file without the <code>.rs</code> extension.</p>
<p>This write-up by Brandon W Maister discusses debugging in more detail:
<a href="https://quodlibetor.github.io/posts/debugging-rusts-new-custom-derive-system/">Debugging Rust’s new Custom Derive system</a>.</p>
<br>
<h2 id="optional-features"><a href="#optional-features">Optional features</a></h2>
<p>Syn puts a lot of functionality behind optional features in order to
optimize compile time for the most common use cases. The following features
are available.</p>
<ul>
<li><strong><code>derive</code></strong> <em>(enabled by default)</em> — Data structures for representing the
possible input to a derive macro, including structs and enums and types.</li>
<li><strong><code>full</code></strong> — Data structures for representing the syntax tree of all valid
Rust source code, including items and expressions.</li>
<li><strong><code>parsing</code></strong> <em>(enabled by default)</em> — Ability to parse input tokens into
a syntax tree node of a chosen type.</li>
<li><strong><code>printing</code></strong> <em>(enabled by default)</em> — Ability to print a syntax tree
node as tokens of Rust source code.</li>
<li><strong><code>visit</code></strong> — Trait for traversing a syntax tree.</li>
<li><strong><code>visit-mut</code></strong> — Trait for traversing and mutating in place a syntax
tree.</li>
<li><strong><code>fold</code></strong> — Trait for transforming an owned syntax tree.</li>
<li><strong><code>clone-impls</code></strong> <em>(enabled by default)</em> — Clone impls for all syntax tree
types.</li>
<li><strong><code>extra-traits</code></strong> — Debug, Eq, PartialEq, Hash impls for all syntax tree
types.</li>
<li><strong><code>proc-macro</code></strong> <em>(enabled by default)</em> — Runtime dependency on the
dynamic library libproc_macro from rustc toolchain.</li>
</ul>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.Ident"><code>pub use crate::ident::Ident;</code></div></li><li><div class="item-name" id="reexport.Lifetime"><code>pub use crate::lifetime::<a class="struct" href="struct.Lifetime.html" title="struct syn::Lifetime">Lifetime</a>;</code></div></li><li><div class="item-name" id="reexport.Lifetime-1"><code>pub use crate::lifetime::Lifetime;</code></div></li><li><div class="item-name" id="reexport.Lit"><code>pub use crate::lit::<a class="enum" href="enum.Lit.html" title="enum syn::Lit">Lit</a>;</code></div></li><li><div class="item-name" id="reexport.Lit-1"><code>pub use crate::lit::Lit;</code></div></li><li><div class="item-name" id="reexport.LitBool"><code>pub use crate::lit::<a class="struct" href="struct.LitBool.html" title="struct syn::LitBool">LitBool</a>;</code></div></li><li><div class="item-name" id="reexport.LitBool-1"><code>pub use crate::lit::LitBool;</code></div></li><li><div class="item-name" id="reexport.LitByte"><code>pub use crate::lit::<a class="struct" href="struct.LitByte.html" title="struct syn::LitByte">LitByte</a>;</code></div></li><li><div class="item-name" id="reexport.LitByte-1"><code>pub use crate::lit::LitByte;</code></div></li><li><div class="item-name" id="reexport.LitByteStr"><code>pub use crate::lit::<a class="struct" href="struct.LitByteStr.html" title="struct syn::LitByteStr">LitByteStr</a>;</code></div></li><li><div class="item-name" id="reexport.LitByteStr-1"><code>pub use crate::lit::LitByteStr;</code></div></li><li><div class="item-name" id="reexport.LitChar"><code>pub use crate::lit::<a class="struct" href="struct.LitChar.html" title="struct syn::LitChar">LitChar</a>;</code></div></li><li><div class="item-name" id="reexport.LitChar-1"><code>pub use crate::lit::LitChar;</code></div></li><li><div class="item-name" id="reexport.LitFloat"><code>pub use crate::lit::<a class="struct" href="struct.LitFloat.html" title="struct syn::LitFloat">LitFloat</a>;</code></div></li><li><div class="item-name" id="reexport.LitFloat-1"><code>pub use crate::lit::LitFloat;</code></div></li><li><div class="item-name" id="reexport.LitInt"><code>pub use crate::lit::<a class="struct" href="struct.LitInt.html" title="struct syn::LitInt">LitInt</a>;</code></div></li><li><div class="item-name" id="reexport.LitInt-1"><code>pub use crate::lit::LitInt;</code></div></li><li><div class="item-name" id="reexport.LitStr"><code>pub use crate::lit::<a class="struct" href="struct.LitStr.html" title="struct syn::LitStr">LitStr</a>;</code></div></li><li><div class="item-name" id="reexport.LitStr-1"><code>pub use crate::lit::LitStr;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="buffer/index.html" title="mod syn::buffer">buffer</a></div><div class="desc docblock-short">A stably addressed token buffer supporting efficient traversal based on a
cheaply copyable cursor.</div></li><li><div class="item-name"><a class="mod" href="ext/index.html" title="mod syn::ext">ext</a></div><div class="desc docblock-short">Extension traits to provide parsing methods on foreign types.</div></li><li><div class="item-name"><a class="mod" href="parse/index.html" title="mod syn::parse">parse</a></div><div class="desc docblock-short">Parsing interface for parsing a token stream into a syntax tree node.</div></li><li><div class="item-name"><a class="mod" href="punctuated/index.html" title="mod syn::punctuated">punctuated</a></div><div class="desc docblock-short">A punctuated sequence of syntax tree nodes separated by punctuation.</div></li><li><div class="item-name"><a class="mod" href="spanned/index.html" title="mod syn::spanned">spanned</a></div><div class="desc docblock-short">A trait that can provide the <code>Span</code> of the complete contents of a syntax
tree node.</div></li><li><div class="item-name"><a class="mod" href="token/index.html" title="mod syn::token">token</a></div><div class="desc docblock-short">Tokens representing Rust punctuation, keywords, and delimiters.</div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.Token.html" title="macro syn::Token">Token</a></div><div class="desc docblock-short">A type-macro that expands to the name of the Rust type representation of a
given token.</div></li><li><div class="item-name"><a class="macro" href="macro.braced.html" title="macro syn::braced">braced</a></div><div class="desc docblock-short">Parse a set of curly braces and expose their content to subsequent parsers.</div></li><li><div class="item-name"><a class="macro" href="macro.bracketed.html" title="macro syn::bracketed">bracketed</a></div><div class="desc docblock-short">Parse a set of square brackets and expose their content to subsequent
parsers.</div></li><li><div class="item-name"><a class="macro" href="macro.custom_keyword.html" title="macro syn::custom_keyword">custom_keyword</a></div><div class="desc docblock-short">Define a type that supports parsing and printing a given identifier as if it
were a keyword.</div></li><li><div class="item-name"><a class="macro" href="macro.custom_punctuation.html" title="macro syn::custom_punctuation">custom_punctuation</a></div><div class="desc docblock-short">Define a type that supports parsing and printing a multi-character symbol
as if it were a punctuation token.</div></li><li><div class="item-name"><a class="macro" href="macro.parenthesized.html" title="macro syn::parenthesized">parenthesized</a></div><div class="desc docblock-short">Parse a set of parentheses and expose their content to subsequent parsers.</div></li><li><div class="item-name"><a class="macro" href="macro.parse_macro_input.html" title="macro syn::parse_macro_input">parse_macro_input</a></div><div class="desc docblock-short">Parse the input TokenStream of a macro, triggering a compile error if the
tokens fail to parse.</div></li><li><div class="item-name"><a class="macro" href="macro.parse_quote.html" title="macro syn::parse_quote">parse_quote</a></div><div class="desc docblock-short">Quasi-quotation macro that accepts input like the <a href="https://docs.rs/quote/1.0/quote/index.html"><code>quote!</code></a> macro but uses
type inference to figure out a return type for those tokens.</div></li><li><div class="item-name"><a class="macro" href="macro.parse_quote_spanned.html" title="macro syn::parse_quote_spanned">parse_quote_spanned</a></div><div class="desc docblock-short">This macro is <a href="macro.parse_quote.html" title="macro syn::parse_quote"><code>parse_quote!</code></a> + <a href="../quote/macro.quote_spanned.html" title="macro quote::quote_spanned"><code>quote_spanned!</code></a>.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Abi.html" title="struct syn::Abi">Abi</a></div><div class="desc docblock-short">The binary interface of a function: <code>extern &quot;C&quot;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.AngleBracketedGenericArguments.html" title="struct syn::AngleBracketedGenericArguments">AngleBracketedGenericArguments</a></div><div class="desc docblock-short">Angle bracketed arguments of a path segment: the <code>&lt;K, V&gt;</code> in <code>HashMap&lt;K, V&gt;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Arm.html" title="struct syn::Arm">Arm</a></div><div class="desc docblock-short">One arm of a <code>match</code> expression: <code>0...10 =&gt; { return true; }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Attribute.html" title="struct syn::Attribute">Attribute</a></div><div class="desc docblock-short">An attribute like <code>#[repr(transparent)]</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.BareFnArg.html" title="struct syn::BareFnArg">BareFnArg</a></div><div class="desc docblock-short">An argument in a function type: the <code>usize</code> in <code>fn(usize) -&gt; bool</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Binding.html" title="struct syn::Binding">Binding</a></div><div class="desc docblock-short">A binding (equality constraint) on an associated type: <code>Item = u8</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Block.html" title="struct syn::Block">Block</a></div><div class="desc docblock-short">A braced block containing Rust statements.</div></li><li><div class="item-name"><a class="struct" href="struct.BoundLifetimes.html" title="struct syn::BoundLifetimes">BoundLifetimes</a></div><div class="desc docblock-short">A set of bound lifetimes: <code>for&lt;'a, 'b, 'c&gt;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ConstParam.html" title="struct syn::ConstParam">ConstParam</a></div><div class="desc docblock-short">A const generic parameter: <code>const LENGTH: usize</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Constraint.html" title="struct syn::Constraint">Constraint</a></div><div class="desc docblock-short">An associated type bound: <code>Iterator&lt;Item: Display&gt;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.DataEnum.html" title="struct syn::DataEnum">DataEnum</a></div><div class="desc docblock-short">An enum input to a <code>proc_macro_derive</code> macro.</div></li><li><div class="item-name"><a class="struct" href="struct.DataStruct.html" title="struct syn::DataStruct">DataStruct</a></div><div class="desc docblock-short">A struct input to a <code>proc_macro_derive</code> macro.</div></li><li><div class="item-name"><a class="struct" href="struct.DataUnion.html" title="struct syn::DataUnion">DataUnion</a></div><div class="desc docblock-short">An untagged union input to a <code>proc_macro_derive</code> macro.</div></li><li><div class="item-name"><a class="struct" href="struct.DeriveInput.html" title="struct syn::DeriveInput">DeriveInput</a></div><div class="desc docblock-short">Data structure sent to a <code>proc_macro_derive</code> macro.</div></li><li><div class="item-name"><a class="struct" href="struct.Error.html" title="struct syn::Error">Error</a></div><div class="desc docblock-short">Error returned when a Syn parser cannot parse the input tokens.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprArray.html" title="struct syn::ExprArray">ExprArray</a></div><div class="desc docblock-short">A slice literal expression: <code>[a, b, c, d]</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprAssign.html" title="struct syn::ExprAssign">ExprAssign</a></div><div class="desc docblock-short">An assignment expression: <code>a = compute()</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprAssignOp.html" title="struct syn::ExprAssignOp">ExprAssignOp</a></div><div class="desc docblock-short">A compound assignment expression: <code>counter += 1</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprAsync.html" title="struct syn::ExprAsync">ExprAsync</a></div><div class="desc docblock-short">An async block: <code>async { ... }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprAwait.html" title="struct syn::ExprAwait">ExprAwait</a></div><div class="desc docblock-short">An await expression: <code>fut.await</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprBinary.html" title="struct syn::ExprBinary">ExprBinary</a></div><div class="desc docblock-short">A binary operation: <code>a + b</code>, <code>a * b</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprBlock.html" title="struct syn::ExprBlock">ExprBlock</a></div><div class="desc docblock-short">A blocked scope: <code>{ ... }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprBox.html" title="struct syn::ExprBox">ExprBox</a></div><div class="desc docblock-short">A box expression: <code>box f</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprBreak.html" title="struct syn::ExprBreak">ExprBreak</a></div><div class="desc docblock-short">A <code>break</code>, with an optional label to break and an optional
expression.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprCall.html" title="struct syn::ExprCall">ExprCall</a></div><div class="desc docblock-short">A function call expression: <code>invoke(a, b)</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprCast.html" title="struct syn::ExprCast">ExprCast</a></div><div class="desc docblock-short">A cast expression: <code>foo as f64</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprClosure.html" title="struct syn::ExprClosure">ExprClosure</a></div><div class="desc docblock-short">A closure expression: <code>|a, b| a + b</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprContinue.html" title="struct syn::ExprContinue">ExprContinue</a></div><div class="desc docblock-short">A <code>continue</code>, with an optional label.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprField.html" title="struct syn::ExprField">ExprField</a></div><div class="desc docblock-short">Access of a named struct field (<code>obj.k</code>) or unnamed tuple struct
field (<code>obj.0</code>).</div></li><li><div class="item-name"><a class="struct" href="struct.ExprForLoop.html" title="struct syn::ExprForLoop">ExprForLoop</a></div><div class="desc docblock-short">A for loop: <code>for pat in expr { ... }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprGroup.html" title="struct syn::ExprGroup">ExprGroup</a></div><div class="desc docblock-short">An expression contained within invisible delimiters.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprIf.html" title="struct syn::ExprIf">ExprIf</a></div><div class="desc docblock-short">An <code>if</code> expression with an optional <code>else</code> block: <code>if expr { ... } else { ... }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprIndex.html" title="struct syn::ExprIndex">ExprIndex</a></div><div class="desc docblock-short">A square bracketed indexing expression: <code>vector[2]</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprLet.html" title="struct syn::ExprLet">ExprLet</a></div><div class="desc docblock-short">A <code>let</code> guard: <code>let Some(x) = opt</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprLit.html" title="struct syn::ExprLit">ExprLit</a></div><div class="desc docblock-short">A literal in place of an expression: <code>1</code>, <code>&quot;foo&quot;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprLoop.html" title="struct syn::ExprLoop">ExprLoop</a></div><div class="desc docblock-short">Conditionless loop: <code>loop { ... }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprMacro.html" title="struct syn::ExprMacro">ExprMacro</a></div><div class="desc docblock-short">A macro invocation expression: <code>format!(&quot;{}&quot;, q)</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprMatch.html" title="struct syn::ExprMatch">ExprMatch</a></div><div class="desc docblock-short">A <code>match</code> expression: <code>match n { Some(n) =&gt; {}, None =&gt; {} }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprMethodCall.html" title="struct syn::ExprMethodCall">ExprMethodCall</a></div><div class="desc docblock-short">A method call expression: <code>x.foo::&lt;T&gt;(a, b)</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprParen.html" title="struct syn::ExprParen">ExprParen</a></div><div class="desc docblock-short">A parenthesized expression: <code>(a + b)</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprPath.html" title="struct syn::ExprPath">ExprPath</a></div><div class="desc docblock-short">A path like <code>std::mem::replace</code> possibly containing generic
parameters and a qualified self-type.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprRange.html" title="struct syn::ExprRange">ExprRange</a></div><div class="desc docblock-short">A range expression: <code>1..2</code>, <code>1..</code>, <code>..2</code>, <code>1..=2</code>, <code>..=2</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprReference.html" title="struct syn::ExprReference">ExprReference</a></div><div class="desc docblock-short">A referencing operation: <code>&amp;a</code> or <code>&amp;mut a</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprRepeat.html" title="struct syn::ExprRepeat">ExprRepeat</a></div><div class="desc docblock-short">An array literal constructed from one repeated element: <code>[0u8; N]</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprReturn.html" title="struct syn::ExprReturn">ExprReturn</a></div><div class="desc docblock-short">A <code>return</code>, with an optional value to be returned.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprStruct.html" title="struct syn::ExprStruct">ExprStruct</a></div><div class="desc docblock-short">A struct literal expression: <code>Point { x: 1, y: 1 }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprTry.html" title="struct syn::ExprTry">ExprTry</a></div><div class="desc docblock-short">A try-expression: <code>expr?</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprTryBlock.html" title="struct syn::ExprTryBlock">ExprTryBlock</a></div><div class="desc docblock-short">A try block: <code>try { ... }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprTuple.html" title="struct syn::ExprTuple">ExprTuple</a></div><div class="desc docblock-short">A tuple expression: <code>(a, b, c, d)</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprType.html" title="struct syn::ExprType">ExprType</a></div><div class="desc docblock-short">A type ascription expression: <code>foo: f64</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprUnary.html" title="struct syn::ExprUnary">ExprUnary</a></div><div class="desc docblock-short">A unary operation: <code>!x</code>, <code>*x</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprUnsafe.html" title="struct syn::ExprUnsafe">ExprUnsafe</a></div><div class="desc docblock-short">An unsafe block: <code>unsafe { ... }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprWhile.html" title="struct syn::ExprWhile">ExprWhile</a></div><div class="desc docblock-short">A while loop: <code>while expr { ... }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ExprYield.html" title="struct syn::ExprYield">ExprYield</a></div><div class="desc docblock-short">A yield expression: <code>yield expr</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Field.html" title="struct syn::Field">Field</a></div><div class="desc docblock-short">A field of a struct or enum variant.</div></li><li><div class="item-name"><a class="struct" href="struct.FieldPat.html" title="struct syn::FieldPat">FieldPat</a></div><div class="desc docblock-short">A single field in a struct pattern.</div></li><li><div class="item-name"><a class="struct" href="struct.FieldValue.html" title="struct syn::FieldValue">FieldValue</a></div><div class="desc docblock-short">A field-value pair in a struct literal.</div></li><li><div class="item-name"><a class="struct" href="struct.FieldsNamed.html" title="struct syn::FieldsNamed">FieldsNamed</a></div><div class="desc docblock-short">Named fields of a struct or struct variant such as <code>Point { x: f64, y: f64 }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.FieldsUnnamed.html" title="struct syn::FieldsUnnamed">FieldsUnnamed</a></div><div class="desc docblock-short">Unnamed fields of a tuple struct or tuple variant such as <code>Some(T)</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.File.html" title="struct syn::File">File</a></div><div class="desc docblock-short">A complete file of Rust source code.</div></li><li><div class="item-name"><a class="struct" href="struct.ForeignItemFn.html" title="struct syn::ForeignItemFn">ForeignItemFn</a></div><div class="desc docblock-short">A foreign function in an <code>extern</code> block.</div></li><li><div class="item-name"><a class="struct" href="struct.ForeignItemMacro.html" title="struct syn::ForeignItemMacro">ForeignItemMacro</a></div><div class="desc docblock-short">A macro invocation within an extern block.</div></li><li><div class="item-name"><a class="struct" href="struct.ForeignItemStatic.html" title="struct syn::ForeignItemStatic">ForeignItemStatic</a></div><div class="desc docblock-short">A foreign static item in an <code>extern</code> block: <code>static ext: u8</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ForeignItemType.html" title="struct syn::ForeignItemType">ForeignItemType</a></div><div class="desc docblock-short">A foreign type in an <code>extern</code> block: <code>type void</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Generics.html" title="struct syn::Generics">Generics</a></div><div class="desc docblock-short">Lifetimes and type parameters attached to a declaration of a function,
enum, trait, etc.</div></li><li><div class="item-name"><a class="struct" href="struct.Ident.html" title="struct syn::Ident">Ident</a></div><div class="desc docblock-short">A word of Rust code, which may be a keyword or legal variable name.</div></li><li><div class="item-name"><a class="struct" href="struct.ImplGenerics.html" title="struct syn::ImplGenerics">ImplGenerics</a></div><div class="desc docblock-short">Returned by <code>Generics::split_for_impl</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ImplItemConst.html" title="struct syn::ImplItemConst">ImplItemConst</a></div><div class="desc docblock-short">An associated constant within an impl block.</div></li><li><div class="item-name"><a class="struct" href="struct.ImplItemMacro.html" title="struct syn::ImplItemMacro">ImplItemMacro</a></div><div class="desc docblock-short">A macro invocation within an impl block.</div></li><li><div class="item-name"><a class="struct" href="struct.ImplItemMethod.html" title="struct syn::ImplItemMethod">ImplItemMethod</a></div><div class="desc docblock-short">A method within an impl block.</div></li><li><div class="item-name"><a class="struct" href="struct.ImplItemType.html" title="struct syn::ImplItemType">ImplItemType</a></div><div class="desc docblock-short">An associated type within an impl block.</div></li><li><div class="item-name"><a class="struct" href="struct.Index.html" title="struct syn::Index">Index</a></div><div class="desc docblock-short">The index of an unnamed tuple struct field.</div></li><li><div class="item-name"><a class="struct" href="struct.ItemConst.html" title="struct syn::ItemConst">ItemConst</a></div><div class="desc docblock-short">A constant item: <code>const MAX: u16 = 65535</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ItemEnum.html" title="struct syn::ItemEnum">ItemEnum</a></div><div class="desc docblock-short">An enum definition: <code>enum Foo&lt;A, B&gt; { A(A), B(B) }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ItemExternCrate.html" title="struct syn::ItemExternCrate">ItemExternCrate</a></div><div class="desc docblock-short">An <code>extern crate</code> item: <code>extern crate serde</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ItemFn.html" title="struct syn::ItemFn">ItemFn</a></div><div class="desc docblock-short">A free-standing function: <code>fn process(n: usize) -&gt; Result&lt;()&gt; { ... }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ItemForeignMod.html" title="struct syn::ItemForeignMod">ItemForeignMod</a></div><div class="desc docblock-short">A block of foreign items: <code>extern &quot;C&quot; { ... }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ItemImpl.html" title="struct syn::ItemImpl">ItemImpl</a></div><div class="desc docblock-short">An impl block providing trait or associated items: <code>impl&lt;A&gt; Trait for Data&lt;A&gt; { ... }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ItemMacro.html" title="struct syn::ItemMacro">ItemMacro</a></div><div class="desc docblock-short">A macro invocation, which includes <code>macro_rules!</code> definitions.</div></li><li><div class="item-name"><a class="struct" href="struct.ItemMacro2.html" title="struct syn::ItemMacro2">ItemMacro2</a></div><div class="desc docblock-short">A 2.0-style declarative macro introduced by the <code>macro</code> keyword.</div></li><li><div class="item-name"><a class="struct" href="struct.ItemMod.html" title="struct syn::ItemMod">ItemMod</a></div><div class="desc docblock-short">A module or module declaration: <code>mod m</code> or <code>mod m { ... }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ItemStatic.html" title="struct syn::ItemStatic">ItemStatic</a></div><div class="desc docblock-short">A static item: <code>static BIKE: Shed = Shed(42)</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ItemStruct.html" title="struct syn::ItemStruct">ItemStruct</a></div><div class="desc docblock-short">A struct definition: <code>struct Foo&lt;A&gt; { x: A }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ItemTrait.html" title="struct syn::ItemTrait">ItemTrait</a></div><div class="desc docblock-short">A trait definition: <code>pub trait Iterator { ... }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ItemTraitAlias.html" title="struct syn::ItemTraitAlias">ItemTraitAlias</a></div><div class="desc docblock-short">A trait alias: <code>pub trait SharableIterator = Iterator + Sync</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ItemType.html" title="struct syn::ItemType">ItemType</a></div><div class="desc docblock-short">A type alias: <code>type Result&lt;T&gt; = std::result::Result&lt;T, MyError&gt;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ItemUnion.html" title="struct syn::ItemUnion">ItemUnion</a></div><div class="desc docblock-short">A union definition: <code>union Foo&lt;A, B&gt; { x: A, y: B }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ItemUse.html" title="struct syn::ItemUse">ItemUse</a></div><div class="desc docblock-short">A use declaration: <code>use std::collections::HashMap</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Label.html" title="struct syn::Label">Label</a></div><div class="desc docblock-short">A lifetime labeling a <code>for</code>, <code>while</code>, or <code>loop</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Lifetime.html" title="struct syn::Lifetime">Lifetime</a></div><div class="desc docblock-short">A Rust lifetime: <code>'a</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.LifetimeDef.html" title="struct syn::LifetimeDef">LifetimeDef</a></div><div class="desc docblock-short">A lifetime definition: <code>'a: 'b + 'c + 'd</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.LitBool.html" title="struct syn::LitBool">LitBool</a></div><div class="desc docblock-short">A boolean literal: <code>true</code> or <code>false</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.LitByte.html" title="struct syn::LitByte">LitByte</a></div><div class="desc docblock-short">A byte literal: <code>b'f'</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.LitByteStr.html" title="struct syn::LitByteStr">LitByteStr</a></div><div class="desc docblock-short">A byte string literal: <code>b&quot;foo&quot;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.LitChar.html" title="struct syn::LitChar">LitChar</a></div><div class="desc docblock-short">A character literal: <code>'a'</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.LitFloat.html" title="struct syn::LitFloat">LitFloat</a></div><div class="desc docblock-short">A floating point literal: <code>1f64</code> or <code>1.0e10f64</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.LitInt.html" title="struct syn::LitInt">LitInt</a></div><div class="desc docblock-short">An integer literal: <code>1</code> or <code>1u16</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.LitStr.html" title="struct syn::LitStr">LitStr</a></div><div class="desc docblock-short">A UTF-8 string literal: <code>&quot;foo&quot;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Local.html" title="struct syn::Local">Local</a></div><div class="desc docblock-short">A local <code>let</code> binding: <code>let x: u64 = s.parse()?</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Macro.html" title="struct syn::Macro">Macro</a></div><div class="desc docblock-short">A macro invocation: <code>println!(&quot;{}&quot;, mac)</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.MetaList.html" title="struct syn::MetaList">MetaList</a></div><div class="desc docblock-short">A structured list within an attribute, like <code>derive(Copy, Clone)</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.MetaNameValue.html" title="struct syn::MetaNameValue">MetaNameValue</a></div><div class="desc docblock-short">A name-value pair within an attribute, like <code>feature = &quot;nightly&quot;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.MethodTurbofish.html" title="struct syn::MethodTurbofish">MethodTurbofish</a></div><div class="desc docblock-short">The <code>::&lt;&gt;</code> explicit type parameters passed to a method call:
<code>parse::&lt;u64&gt;()</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ParenthesizedGenericArguments.html" title="struct syn::ParenthesizedGenericArguments">ParenthesizedGenericArguments</a></div><div class="desc docblock-short">Arguments of a function path segment: the <code>(A, B) -&gt; C</code> in <code>Fn(A,B) -&gt; C</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.PatBox.html" title="struct syn::PatBox">PatBox</a></div><div class="desc docblock-short">A box pattern: <code>box v</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.PatIdent.html" title="struct syn::PatIdent">PatIdent</a></div><div class="desc docblock-short">A pattern that binds a new variable: <code>ref mut binding @ SUBPATTERN</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.PatLit.html" title="struct syn::PatLit">PatLit</a></div><div class="desc docblock-short">A literal pattern: <code>0</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.PatMacro.html" title="struct syn::PatMacro">PatMacro</a></div><div class="desc docblock-short">A macro in pattern position.</div></li><li><div class="item-name"><a class="struct" href="struct.PatOr.html" title="struct syn::PatOr">PatOr</a></div><div class="desc docblock-short">A pattern that matches any one of a set of cases.</div></li><li><div class="item-name"><a class="struct" href="struct.PatPath.html" title="struct syn::PatPath">PatPath</a></div><div class="desc docblock-short">A path pattern like <code>Color::Red</code>, optionally qualified with a
self-type.</div></li><li><div class="item-name"><a class="struct" href="struct.PatRange.html" title="struct syn::PatRange">PatRange</a></div><div class="desc docblock-short">A range pattern: <code>1..=2</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.PatReference.html" title="struct syn::PatReference">PatReference</a></div><div class="desc docblock-short">A reference pattern: <code>&amp;mut var</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.PatRest.html" title="struct syn::PatRest">PatRest</a></div><div class="desc docblock-short">The dots in a tuple or slice pattern: <code>[0, 1, ..]</code></div></li><li><div class="item-name"><a class="struct" href="struct.PatSlice.html" title="struct syn::PatSlice">PatSlice</a></div><div class="desc docblock-short">A dynamically sized slice pattern: <code>[a, b, ref i @ .., y, z]</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.PatStruct.html" title="struct syn::PatStruct">PatStruct</a></div><div class="desc docblock-short">A struct or struct variant pattern: <code>Variant { x, y, .. }</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.PatTuple.html" title="struct syn::PatTuple">PatTuple</a></div><div class="desc docblock-short">A tuple pattern: <code>(a, b)</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.PatTupleStruct.html" title="struct syn::PatTupleStruct">PatTupleStruct</a></div><div class="desc docblock-short">A tuple struct or tuple variant pattern: <code>Variant(x, y, .., z)</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.PatType.html" title="struct syn::PatType">PatType</a></div><div class="desc docblock-short">A type ascription pattern: <code>foo: f64</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.PatWild.html" title="struct syn::PatWild">PatWild</a></div><div class="desc docblock-short">A pattern that matches any value: <code>_</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Path.html" title="struct syn::Path">Path</a></div><div class="desc docblock-short">A path at which a named item is exported (e.g. <code>std::collections::HashMap</code>).</div></li><li><div class="item-name"><a class="struct" href="struct.PathSegment.html" title="struct syn::PathSegment">PathSegment</a></div><div class="desc docblock-short">A segment of a path together with any path arguments on that segment.</div></li><li><div class="item-name"><a class="struct" href="struct.PredicateEq.html" title="struct syn::PredicateEq">PredicateEq</a></div><div class="desc docblock-short">An equality predicate in a <code>where</code> clause (unsupported).</div></li><li><div class="item-name"><a class="struct" href="struct.PredicateLifetime.html" title="struct syn::PredicateLifetime">PredicateLifetime</a></div><div class="desc docblock-short">A lifetime predicate in a <code>where</code> clause: <code>'a: 'b + 'c</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.PredicateType.html" title="struct syn::PredicateType">PredicateType</a></div><div class="desc docblock-short">A type predicate in a <code>where</code> clause: <code>for&lt;'c&gt; Foo&lt;'c&gt;: Trait&lt;'c&gt;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.QSelf.html" title="struct syn::QSelf">QSelf</a></div><div class="desc docblock-short">The explicit Self type in a qualified path: the <code>T</code> in <code>&lt;T as Display&gt;::fmt</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Receiver.html" title="struct syn::Receiver">Receiver</a></div><div class="desc docblock-short">The <code>self</code> argument of an associated method, whether taken by value
or by reference.</div></li><li><div class="item-name"><a class="struct" href="struct.Signature.html" title="struct syn::Signature">Signature</a></div><div class="desc docblock-short">A function signature in a trait or implementation: <code>unsafe fn initialize(&amp;self)</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.TraitBound.html" title="struct syn::TraitBound">TraitBound</a></div><div class="desc docblock-short">A trait used as a bound on a type parameter.</div></li><li><div class="item-name"><a class="struct" href="struct.TraitItemConst.html" title="struct syn::TraitItemConst">TraitItemConst</a></div><div class="desc docblock-short">An associated constant within the definition of a trait.</div></li><li><div class="item-name"><a class="struct" href="struct.TraitItemMacro.html" title="struct syn::TraitItemMacro">TraitItemMacro</a></div><div class="desc docblock-short">A macro invocation within the definition of a trait.</div></li><li><div class="item-name"><a class="struct" href="struct.TraitItemMethod.html" title="struct syn::TraitItemMethod">TraitItemMethod</a></div><div class="desc docblock-short">A trait method within the definition of a trait.</div></li><li><div class="item-name"><a class="struct" href="struct.TraitItemType.html" title="struct syn::TraitItemType">TraitItemType</a></div><div class="desc docblock-short">An associated type within the definition of a trait.</div></li><li><div class="item-name"><a class="struct" href="struct.Turbofish.html" title="struct syn::Turbofish">Turbofish</a></div><div class="desc docblock-short">Returned by <code>TypeGenerics::as_turbofish</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeArray.html" title="struct syn::TypeArray">TypeArray</a></div><div class="desc docblock-short">A fixed size array type: <code>[T; n]</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeBareFn.html" title="struct syn::TypeBareFn">TypeBareFn</a></div><div class="desc docblock-short">A bare function type: <code>fn(usize) -&gt; bool</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeGenerics.html" title="struct syn::TypeGenerics">TypeGenerics</a></div><div class="desc docblock-short">Returned by <code>Generics::split_for_impl</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeGroup.html" title="struct syn::TypeGroup">TypeGroup</a></div><div class="desc docblock-short">A type contained within invisible delimiters.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeImplTrait.html" title="struct syn::TypeImplTrait">TypeImplTrait</a></div><div class="desc docblock-short">An <code>impl Bound1 + Bound2 + Bound3</code> type where <code>Bound</code> is a trait or
a lifetime.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeInfer.html" title="struct syn::TypeInfer">TypeInfer</a></div><div class="desc docblock-short">Indication that a type should be inferred by the compiler: <code>_</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeMacro.html" title="struct syn::TypeMacro">TypeMacro</a></div><div class="desc docblock-short">A macro in the type position.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeNever.html" title="struct syn::TypeNever">TypeNever</a></div><div class="desc docblock-short">The never type: <code>!</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeParam.html" title="struct syn::TypeParam">TypeParam</a></div><div class="desc docblock-short">A generic type parameter: <code>T: Into&lt;String&gt;</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeParen.html" title="struct syn::TypeParen">TypeParen</a></div><div class="desc docblock-short">A parenthesized type equivalent to the inner type.</div></li><li><div class="item-name"><a class="struct" href="struct.TypePath.html" title="struct syn::TypePath">TypePath</a></div><div class="desc docblock-short">A path like <code>std::slice::Iter</code>, optionally qualified with a
self-type as in <code>&lt;Vec&lt;T&gt; as SomeTrait&gt;::Associated</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.TypePtr.html" title="struct syn::TypePtr">TypePtr</a></div><div class="desc docblock-short">A raw pointer type: <code>*const T</code> or <code>*mut T</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeReference.html" title="struct syn::TypeReference">TypeReference</a></div><div class="desc docblock-short">A reference type: <code>&amp;'a T</code> or <code>&amp;'a mut T</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeSlice.html" title="struct syn::TypeSlice">TypeSlice</a></div><div class="desc docblock-short">A dynamically sized slice type: <code>[T]</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeTraitObject.html" title="struct syn::TypeTraitObject">TypeTraitObject</a></div><div class="desc docblock-short">A trait object type <code>dyn Bound1 + Bound2 + Bound3</code> where <code>Bound</code> is a
trait or a lifetime.</div></li><li><div class="item-name"><a class="struct" href="struct.TypeTuple.html" title="struct syn::TypeTuple">TypeTuple</a></div><div class="desc docblock-short">A tuple type: <code>(A, B, C, String)</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.UseGlob.html" title="struct syn::UseGlob">UseGlob</a></div><div class="desc docblock-short">A glob import in a <code>use</code> item: <code>*</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.UseGroup.html" title="struct syn::UseGroup">UseGroup</a></div><div class="desc docblock-short">A braced group of imports in a <code>use</code> item: <code>{A, B, C}</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.UseName.html" title="struct syn::UseName">UseName</a></div><div class="desc docblock-short">An identifier imported by a <code>use</code> item: <code>HashMap</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.UsePath.html" title="struct syn::UsePath">UsePath</a></div><div class="desc docblock-short">A path prefix of imports in a <code>use</code> item: <code>std::...</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.UseRename.html" title="struct syn::UseRename">UseRename</a></div><div class="desc docblock-short">An renamed identifier imported by a <code>use</code> item: <code>HashMap as Map</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Variadic.html" title="struct syn::Variadic">Variadic</a></div><div class="desc docblock-short">The variadic argument of a foreign function.</div></li><li><div class="item-name"><a class="struct" href="struct.Variant.html" title="struct syn::Variant">Variant</a></div><div class="desc docblock-short">An enum variant.</div></li><li><div class="item-name"><a class="struct" href="struct.VisCrate.html" title="struct syn::VisCrate">VisCrate</a></div><div class="desc docblock-short">A crate-level visibility: <code>crate</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.VisPublic.html" title="struct syn::VisPublic">VisPublic</a></div><div class="desc docblock-short">A public visibility level: <code>pub</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.VisRestricted.html" title="struct syn::VisRestricted">VisRestricted</a></div><div class="desc docblock-short">A visibility level restricted to some path: <code>pub(self)</code> or
<code>pub(super)</code> or <code>pub(crate)</code> or <code>pub(in some::module)</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.WhereClause.html" title="struct syn::WhereClause">WhereClause</a></div><div class="desc docblock-short">A <code>where</code> clause in a definition: <code>where T: Deserialize&lt;'de&gt;, D: 'static</code>.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.AttrStyle.html" title="enum syn::AttrStyle">AttrStyle</a></div><div class="desc docblock-short">Distinguishes between attributes that decorate an item and attributes
that are contained within an item.</div></li><li><div class="item-name"><a class="enum" href="enum.BinOp.html" title="enum syn::BinOp">BinOp</a></div><div class="desc docblock-short">A binary operator: <code>+</code>, <code>+=</code>, <code>&amp;</code>.</div></li><li><div class="item-name"><a class="enum" href="enum.Data.html" title="enum syn::Data">Data</a></div><div class="desc docblock-short">The storage of a struct, enum or union data structure.</div></li><li><div class="item-name"><a class="enum" href="enum.Expr.html" title="enum syn::Expr">Expr</a></div><div class="desc docblock-short">A Rust expression.</div></li><li><div class="item-name"><a class="enum" href="enum.Fields.html" title="enum syn::Fields">Fields</a></div><div class="desc docblock-short">Data stored within an enum variant or struct.</div></li><li><div class="item-name"><a class="enum" href="enum.FnArg.html" title="enum syn::FnArg">FnArg</a></div><div class="desc docblock-short">An argument in a function signature: the <code>n: usize</code> in <code>fn f(n: usize)</code>.</div></li><li><div class="item-name"><a class="enum" href="enum.ForeignItem.html" title="enum syn::ForeignItem">ForeignItem</a></div><div class="desc docblock-short">An item within an <code>extern</code> block.</div></li><li><div class="item-name"><a class="enum" href="enum.GenericArgument.html" title="enum syn::GenericArgument">GenericArgument</a></div><div class="desc docblock-short">An individual generic argument, like <code>'a</code>, <code>T</code>, or <code>Item = T</code>.</div></li><li><div class="item-name"><a class="enum" href="enum.GenericMethodArgument.html" title="enum syn::GenericMethodArgument">GenericMethodArgument</a></div><div class="desc docblock-short">An individual generic argument to a method, like <code>T</code>.</div></li><li><div class="item-name"><a class="enum" href="enum.GenericParam.html" title="enum syn::GenericParam">GenericParam</a></div><div class="desc docblock-short">A generic type parameter, lifetime, or const generic: <code>T: Into&lt;String&gt;</code>,
<code>'a: 'b</code>, <code>const LEN: usize</code>.</div></li><li><div class="item-name"><a class="enum" href="enum.ImplItem.html" title="enum syn::ImplItem">ImplItem</a></div><div class="desc docblock-short">An item within an impl block.</div></li><li><div class="item-name"><a class="enum" href="enum.Item.html" title="enum syn::Item">Item</a></div><div class="desc docblock-short">Things that can appear directly inside of a module or scope.</div></li><li><div class="item-name"><a class="enum" href="enum.Lit.html" title="enum syn::Lit">Lit</a></div><div class="desc docblock-short">A Rust literal such as a string or integer or boolean.</div></li><li><div class="item-name"><a class="enum" href="enum.MacroDelimiter.html" title="enum syn::MacroDelimiter">MacroDelimiter</a></div><div class="desc docblock-short">A grouping token that surrounds a macro body: <code>m!(...)</code> or <code>m!{...}</code> or <code>m![...]</code>.</div></li><li><div class="item-name"><a class="enum" href="enum.Member.html" title="enum syn::Member">Member</a></div><div class="desc docblock-short">A struct or tuple struct field accessed in a struct literal or field
expression.</div></li><li><div class="item-name"><a class="enum" href="enum.Meta.html" title="enum syn::Meta">Meta</a></div><div class="desc docblock-short">Content of a compile-time structured attribute.</div></li><li><div class="item-name"><a class="enum" href="enum.NestedMeta.html" title="enum syn::NestedMeta">NestedMeta</a></div><div class="desc docblock-short">Element of a compile-time attribute list.</div></li><li><div class="item-name"><a class="enum" href="enum.Pat.html" title="enum syn::Pat">Pat</a></div><div class="desc docblock-short">A pattern in a local binding, function signature, match expression, or
various other places.</div></li><li><div class="item-name"><a class="enum" href="enum.PathArguments.html" title="enum syn::PathArguments">PathArguments</a></div><div class="desc docblock-short">Angle bracketed or parenthesized arguments of a path segment.</div></li><li><div class="item-name"><a class="enum" href="enum.RangeLimits.html" title="enum syn::RangeLimits">RangeLimits</a></div><div class="desc docblock-short">Limit types of a range, inclusive or exclusive.</div></li><li><div class="item-name"><a class="enum" href="enum.ReturnType.html" title="enum syn::ReturnType">ReturnType</a></div><div class="desc docblock-short">Return type of a function signature.</div></li><li><div class="item-name"><a class="enum" href="enum.Stmt.html" title="enum syn::Stmt">Stmt</a></div><div class="desc docblock-short">A statement, usually ending in a semicolon.</div></li><li><div class="item-name"><a class="enum" href="enum.StrStyle.html" title="enum syn::StrStyle">StrStyle</a></div><div class="desc docblock-short">The style of a string literal, either plain quoted or a raw string like
<code>r##&quot;data&quot;##</code>.</div></li><li><div class="item-name"><a class="enum" href="enum.TraitBoundModifier.html" title="enum syn::TraitBoundModifier">TraitBoundModifier</a></div><div class="desc docblock-short">A modifier on a trait bound, currently only used for the <code>?</code> in
<code>?Sized</code>.</div></li><li><div class="item-name"><a class="enum" href="enum.TraitItem.html" title="enum syn::TraitItem">TraitItem</a></div><div class="desc docblock-short">An item declaration within the definition of a trait.</div></li><li><div class="item-name"><a class="enum" href="enum.Type.html" title="enum syn::Type">Type</a></div><div class="desc docblock-short">The possible types that a Rust value could have.</div></li><li><div class="item-name"><a class="enum" href="enum.TypeParamBound.html" title="enum syn::TypeParamBound">TypeParamBound</a></div><div class="desc docblock-short">A trait or lifetime used as a bound on a type parameter.</div></li><li><div class="item-name"><a class="enum" href="enum.UnOp.html" title="enum syn::UnOp">UnOp</a></div><div class="desc docblock-short">A unary operator: <code>*</code>, <code>!</code>, <code>-</code>.</div></li><li><div class="item-name"><a class="enum" href="enum.UseTree.html" title="enum syn::UseTree">UseTree</a></div><div class="desc docblock-short">A suffix of an import tree in a <code>use</code> item: <code>Type as Renamed</code> or <code>*</code>.</div></li><li><div class="item-name"><a class="enum" href="enum.Visibility.html" title="enum syn::Visibility">Visibility</a></div><div class="desc docblock-short">The visibility level of an item: inherited or <code>pub</code> or
<code>pub(restricted)</code>.</div></li><li><div class="item-name"><a class="enum" href="enum.WherePredicate.html" title="enum syn::WherePredicate">WherePredicate</a></div><div class="desc docblock-short">A single predicate in a <code>where</code> clause: <code>T: Deserialize&lt;'de&gt;</code>.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.parse.html" title="fn syn::parse">parse</a></div><div class="desc docblock-short">Parse tokens of source code into the chosen syntax tree node.</div></li><li><div class="item-name"><a class="fn" href="fn.parse2.html" title="fn syn::parse2">parse2</a></div><div class="desc docblock-short">Parse a proc-macro2 token stream into the chosen syntax tree node.</div></li><li><div class="item-name"><a class="fn" href="fn.parse_file.html" title="fn syn::parse_file">parse_file</a></div><div class="desc docblock-short">Parse the content of a file of Rust code.</div></li><li><div class="item-name"><a class="fn" href="fn.parse_str.html" title="fn syn::parse_str">parse_str</a></div><div class="desc docblock-short">Parse a string of Rust code into the chosen syntax tree node.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Aliases</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.AttributeArgs.html" title="type syn::AttributeArgs">AttributeArgs</a></div><div class="desc docblock-short">Conventional argument type associated with an invocation of an attribute
macro.</div></li><li><div class="item-name"><a class="type" href="type.Result.html" title="type syn::Result">Result</a></div><div class="desc docblock-short">The result of a Syn parser.</div></li></ul></section></div></main></body></html>