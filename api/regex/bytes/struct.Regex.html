<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A compiled regular expression for matching arbitrary bytes."><meta name="keywords" content="rust, rustlang, rust-lang, Regex"><title>Regex in regex::bytes - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../regex/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../regex/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Regex</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.as_str">as_str</a></li><li><a href="#method.capture_locations">capture_locations</a></li><li><a href="#method.capture_names">capture_names</a></li><li><a href="#method.captures">captures</a></li><li><a href="#method.captures_iter">captures_iter</a></li><li><a href="#method.captures_len">captures_len</a></li><li><a href="#method.captures_read">captures_read</a></li><li><a href="#method.captures_read_at">captures_read_at</a></li><li><a href="#method.find">find</a></li><li><a href="#method.find_at">find_at</a></li><li><a href="#method.find_iter">find_iter</a></li><li><a href="#method.is_match">is_match</a></li><li><a href="#method.is_match_at">is_match_at</a></li><li><a href="#method.new">new</a></li><li><a href="#method.replace">replace</a></li><li><a href="#method.replace_all">replace_all</a></li><li><a href="#method.replacen">replacen</a></li><li><a href="#method.shortest_match">shortest_match</a></li><li><a href="#method.shortest_match_at">shortest_match_at</a></li><li><a href="#method.split">split</a></li><li><a href="#method.splitn">splitn</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-Clone-for-Regex">Clone</a></li><li><a href="#impl-Debug-for-Regex">Debug</a></li><li><a href="#impl-Display-for-Regex">Display</a></li><li><a href="#impl-FromStr-for-Regex">FromStr</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe-for-Regex">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Regex">Send</a></li><li><a href="#impl-Sync-for-Regex">Sync</a></li><li><a href="#impl-Unpin-for-Regex">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Regex">UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any-for-Regex">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-Regex">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-Regex">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-Regex">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-Regex">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-Regex">ToOwned</a></li><li><a href="#impl-ToString-for-Regex">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E-for-Regex">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-Regex">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In regex::bytes</a></h2></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../regex/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Struct <a href="../index.html">regex</a>::<wbr><a href="index.html">bytes</a>::<wbr><a class="struct" href="#">Regex</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/regex/re_bytes.rs.html#78">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code>pub struct Regex(_);</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A compiled regular expression for matching arbitrary bytes.</p>
<p>It can be used to search, split or replace text. All searching is done with
an implicit <code>.*?</code> at the beginning and end of an expression. To force an
expression to match the whole string (or a prefix or a suffix), you must
use an anchor like <code>^</code> or <code>$</code> (or <code>\A</code> and <code>\z</code>).</p>
<p>Like the <code>Regex</code> type in the parent module, matches with this regex return
byte offsets into the search text. <strong>Unlike</strong> the parent <code>Regex</code> type,
these byte offsets may not correspond to UTF-8 sequence boundaries since
the regexes in this module can match arbitrary bytes.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Regex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#114-531">source</a></span><a href="#impl-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.Regex.html" title="struct regex::bytes::Regex">Regex</a></h3></section></summary><div class="docblock"><p>Core regular expression methods.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.new" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#119-121">source</a></span><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>(re: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Regex.html" title="struct regex::bytes::Regex">Regex</a>, <a class="enum" href="../enum.Error.html" title="enum regex::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Compiles a regular expression. Once compiled, it can be used repeatedly
to search, split or replace text in a string.</p>
<p>If an invalid expression is given, then an error is returned.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_match" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#142-144">source</a></span><h4 class="code-header">pub fn <a href="#method.is_match" class="fnname">is_match</a>(&amp;self, text: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if there is a match for the regex in the
string given.</p>
<p>It is recommended to use this method if all you need to do is test
a match, since the underlying matching engine may be able to do less
work.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<p>Test if some text contains at least one word with exactly 13 ASCII word
bytes:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">b&quot;I categorically deny having triskaidekaphobia.&quot;</span>;
<span class="macro">assert!</span>(Regex::new(<span class="string">r&quot;\b\w{13}\b&quot;</span>).unwrap().is_match(text));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.find" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#166-168">source</a></span><h4 class="code-header">pub fn <a href="#method.find" class="fnname">find</a>&lt;'t&gt;(&amp;self, text: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Match.html" title="struct regex::bytes::Match">Match</a>&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the start and end byte range of the leftmost-first match in
<code>text</code>. If no match exists, then <code>None</code> is returned.</p>
<p>Note that this should only be used if you want to discover the position
of the match. Testing the existence of a match is faster if you use
<code>is_match</code>.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<p>Find the start and end location of the first word with exactly 13
ASCII word bytes:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">b&quot;I categorically deny having triskaidekaphobia.&quot;</span>;
<span class="kw">let </span>mat = Regex::new(<span class="string">r&quot;\b\w{13}\b&quot;</span>).unwrap().find(text).unwrap();
<span class="macro">assert_eq!</span>((mat.start(), mat.end()), (<span class="number">2</span>, <span class="number">15</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.find_iter" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#188-190">source</a></span><h4 class="code-header">pub fn <a href="#method.find_iter" class="fnname">find_iter</a>&lt;'r, 't&gt;(&amp;'r self, text: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="struct" href="struct.Matches.html" title="struct regex::bytes::Matches">Matches</a>&lt;'r, 't&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.Matches.html" title="struct regex::bytes::Matches">Matches</a>&lt;'r, 't&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'r, 't&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.Matches.html" title="struct regex::bytes::Matches">Matches</a>&lt;'r, 't&gt;</span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="struct" href="struct.Match.html" title="struct regex::bytes::Match">Match</a>&lt;'t&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator for each successive non-overlapping match in
<code>text</code>, returning the start and end byte indices with respect to
<code>text</code>.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<p>Find the start and end location of every word with exactly 13 ASCII
word bytes:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">b&quot;Retroactively relinquishing remunerations is reprehensible.&quot;</span>;
<span class="kw">for </span>mat <span class="kw">in </span>Regex::new(<span class="string">r&quot;\b\w{13}\b&quot;</span>).unwrap().find_iter(text) {
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, mat);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#255-262">source</a></span><h4 class="code-header">pub fn <a href="#method.captures" class="fnname">captures</a>&lt;'t&gt;(&amp;self, text: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Captures.html" title="struct regex::bytes::Captures">Captures</a>&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the capture groups corresponding to the leftmost-first
match in <code>text</code>. Capture group <code>0</code> always corresponds to the entire
match. If no match is found, then <code>None</code> is returned.</p>
<p>You should only use <code>captures</code> if you need access to the location of
capturing group matches. Otherwise, <code>find</code> is faster for discovering
the location of the overall match.</p>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<p>Say you have some text with movie names and their release years,
like “‘Citizen Kane’ (1941)”. It’d be nice if we could search for text
looking like that, while also extracting the movie name and its release
year separately.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r&quot;&#39;([^&#39;]+)&#39;\s+\((\d{4})\)&quot;</span>).unwrap();
<span class="kw">let </span>text = <span class="string">b&quot;Not my favorite movie: &#39;Citizen Kane&#39; (1941).&quot;</span>;
<span class="kw">let </span>caps = re.captures(text).unwrap();
<span class="macro">assert_eq!</span>(caps.get(<span class="number">1</span>).unwrap().as_bytes(), <span class="kw-2">&amp;</span><span class="string">b&quot;Citizen Kane&quot;</span>[..]);
<span class="macro">assert_eq!</span>(caps.get(<span class="number">2</span>).unwrap().as_bytes(), <span class="kw-2">&amp;</span><span class="string">b&quot;1941&quot;</span>[..]);
<span class="macro">assert_eq!</span>(caps.get(<span class="number">0</span>).unwrap().as_bytes(), <span class="kw-2">&amp;</span><span class="string">b&quot;&#39;Citizen Kane&#39; (1941)&quot;</span>[..]);
<span class="comment">// You can also access the groups by index using the Index notation.
// Note that this will panic on an invalid index.
</span><span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="number">1</span>], <span class="string">b&quot;Citizen Kane&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="number">2</span>], <span class="string">b&quot;1941&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="number">0</span>], <span class="string">b&quot;&#39;Citizen Kane&#39; (1941)&quot;</span>);</code></pre></div>
<p>Note that the full match is at capture group <code>0</code>. Each subsequent
capture group is indexed by the order of its opening <code>(</code>.</p>
<p>We can make this example a bit clearer by using <em>named</em> capture groups:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r&quot;&#39;(?P&lt;title&gt;[^&#39;]+)&#39;\s+\((?P&lt;year&gt;\d{4})\)&quot;</span>)
               .unwrap();
<span class="kw">let </span>text = <span class="string">b&quot;Not my favorite movie: &#39;Citizen Kane&#39; (1941).&quot;</span>;
<span class="kw">let </span>caps = re.captures(text).unwrap();
<span class="macro">assert_eq!</span>(caps.name(<span class="string">&quot;title&quot;</span>).unwrap().as_bytes(), <span class="string">b&quot;Citizen Kane&quot;</span>);
<span class="macro">assert_eq!</span>(caps.name(<span class="string">&quot;year&quot;</span>).unwrap().as_bytes(), <span class="string">b&quot;1941&quot;</span>);
<span class="macro">assert_eq!</span>(caps.get(<span class="number">0</span>).unwrap().as_bytes(), <span class="kw-2">&amp;</span><span class="string">b&quot;&#39;Citizen Kane&#39; (1941)&quot;</span>[..]);
<span class="comment">// You can also access the groups by name using the Index notation.
// Note that this will panic on an invalid group name.
</span><span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="string">&quot;title&quot;</span>], <span class="string">b&quot;Citizen Kane&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="string">&quot;year&quot;</span>], <span class="string">b&quot;1941&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="number">0</span>], <span class="string">b&quot;&#39;Citizen Kane&#39; (1941)&quot;</span>);
</code></pre></div>
<p>Here we name the capture groups, which we can access with the <code>name</code>
method or the <code>Index</code> notation with a <code>&amp;str</code>. Note that the named
capture groups are still accessible with <code>get</code> or the <code>Index</code> notation
with a <code>usize</code>.</p>
<p>The <code>0</code>th capture group is always unnamed, so it must always be
accessed with <code>get(0)</code> or <code>[0]</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures_iter" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#290-295">source</a></span><h4 class="code-header">pub fn <a href="#method.captures_iter" class="fnname">captures_iter</a>&lt;'r, 't&gt;(&amp;'r self, text: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="struct" href="struct.CaptureMatches.html" title="struct regex::bytes::CaptureMatches">CaptureMatches</a>&lt;'r, 't&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.CaptureMatches.html" title="struct regex::bytes::CaptureMatches">CaptureMatches</a>&lt;'r, 't&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'r, 't&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.CaptureMatches.html" title="struct regex::bytes::CaptureMatches">CaptureMatches</a>&lt;'r, 't&gt;</span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="struct" href="struct.Captures.html" title="struct regex::bytes::Captures">Captures</a>&lt;'t&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over all the non-overlapping capture groups matched
in <code>text</code>. This is operationally the same as <code>find_iter</code>, except it
yields information about capturing group matches.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<p>We can use this to find all movie titles and their release years in
some text, where the movie is formatted like “‘Title’ (xxxx)”:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r&quot;&#39;(?P&lt;title&gt;[^&#39;]+)&#39;\s+\((?P&lt;year&gt;\d{4})\)&quot;</span>)
               .unwrap();
<span class="kw">let </span>text = <span class="string">b&quot;&#39;Citizen Kane&#39; (1941), &#39;The Wizard of Oz&#39; (1939), &#39;M&#39; (1931).&quot;</span>;
<span class="kw">for </span>caps <span class="kw">in </span>re.captures_iter(text) {
    <span class="kw">let </span>title = str::from_utf8(<span class="kw-2">&amp;</span>caps[<span class="string">&quot;title&quot;</span>]).unwrap();
    <span class="kw">let </span>year = str::from_utf8(<span class="kw-2">&amp;</span>caps[<span class="string">&quot;year&quot;</span>]).unwrap();
    <span class="macro">println!</span>(<span class="string">&quot;Movie: {:?}, Released: {:?}&quot;</span>, title, year);
}
<span class="comment">// Output:
// Movie: Citizen Kane, Released: 1941
// Movie: The Wizard of Oz, Released: 1939
// Movie: M, Released: 1931</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#317-319">source</a></span><h4 class="code-header">pub fn <a href="#method.split" class="fnname">split</a>&lt;'r, 't&gt;(&amp;'r self, text: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="struct" href="struct.Split.html" title="struct regex::bytes::Split">Split</a>&lt;'r, 't&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.Split.html" title="struct regex::bytes::Split">Split</a>&lt;'r, 't&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'r, 't&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.Split.html" title="struct regex::bytes::Split">Split</a>&lt;'r, 't&gt;</span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>];</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator of substrings of <code>text</code> delimited by a match of the
regular expression. Namely, each element of the iterator corresponds to
text that <em>isn’t</em> matched by the regular expression.</p>
<p>This method will <em>not</em> copy the text given.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<p>To split a string delimited by arbitrary amounts of spaces or tabs:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r&quot;[ \t]+&quot;</span>).unwrap();
<span class="kw">let </span>fields: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = re.split(<span class="string">b&quot;a b \t  c\td    e&quot;</span>).collect();
<span class="macro">assert_eq!</span>(fields, <span class="macro">vec!</span>[
    <span class="kw-2">&amp;</span><span class="string">b&quot;a&quot;</span>[..], <span class="kw-2">&amp;</span><span class="string">b&quot;b&quot;</span>[..], <span class="kw-2">&amp;</span><span class="string">b&quot;c&quot;</span>[..], <span class="kw-2">&amp;</span><span class="string">b&quot;d&quot;</span>[..], <span class="kw-2">&amp;</span><span class="string">b&quot;e&quot;</span>[..],
]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.splitn" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#341-347">source</a></span><h4 class="code-header">pub fn <a href="#method.splitn" class="fnname">splitn</a>&lt;'r, 't&gt;(&amp;'r self, text: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>], limit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="struct.SplitN.html" title="struct regex::bytes::SplitN">SplitN</a>&lt;'r, 't&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.SplitN.html" title="struct regex::bytes::SplitN">SplitN</a>&lt;'r, 't&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'r, 't&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.SplitN.html" title="struct regex::bytes::SplitN">SplitN</a>&lt;'r, 't&gt;</span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>];</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator of at most <code>limit</code> substrings of <code>text</code> delimited
by a match of the regular expression. (A <code>limit</code> of <code>0</code> will return no
substrings.) Namely, each element of the iterator corresponds to text
that <em>isn’t</em> matched by the regular expression. The remainder of the
string that is not split will be the last element in the iterator.</p>
<p>This method will <em>not</em> copy the text given.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<p>Get the first two words in some text:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r&quot;\W+&quot;</span>).unwrap();
<span class="kw">let </span>fields: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = re.splitn(<span class="string">b&quot;Hey! How are you?&quot;</span>, <span class="number">3</span>).collect();
<span class="macro">assert_eq!</span>(fields, <span class="macro">vec!</span>[<span class="kw-2">&amp;</span><span class="string">b&quot;Hey&quot;</span>[..], <span class="kw-2">&amp;</span><span class="string">b&quot;How&quot;</span>[..], <span class="kw-2">&amp;</span><span class="string">b&quot;are you?&quot;</span>[..]]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.replace" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#457-463">source</a></span><h4 class="code-header">pub fn <a href="#method.replace" class="fnname">replace</a>&lt;'t, R:&nbsp;<a class="trait" href="trait.Replacer.html" title="trait regex::bytes::Replacer">Replacer</a>&gt;(&amp;self, text: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>], rep: R) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'t, [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;</h4></section></summary><div class="docblock"><p>Replaces the leftmost-first match with the replacement provided. The
replacement can be a regular byte string (where <code>$N</code> and <code>$name</code> are
expanded to match capture groups) or a function that takes the matches’
<code>Captures</code> and returns the replaced byte string.</p>
<p>If no match is found, then a copy of the byte string is returned
unchanged.</p>
<h5 id="replacement-string-syntax"><a href="#replacement-string-syntax">Replacement string syntax</a></h5>
<p>All instances of <code>$name</code> in the replacement text is replaced with the
corresponding capture group <code>name</code>.</p>
<p><code>name</code> may be an integer corresponding to the index of the
capture group (counted by order of opening parenthesis where <code>0</code> is the
entire match) or it can be a name (consisting of letters, digits or
underscores) corresponding to a named capture group.</p>
<p>If <code>name</code> isn’t a valid capture group (whether the name doesn’t exist
or isn’t a valid index), then it is replaced with the empty string.</p>
<p>The longest possible name is used. e.g., <code>$1a</code> looks up the capture
group named <code>1a</code> and not the capture group at index <code>1</code>. To exert more
precise control over the name, use braces, e.g., <code>${1}a</code>.</p>
<p>To write a literal <code>$</code> use <code>$$</code>.</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<p>Note that this function is polymorphic with respect to the replacement.
In typical usage, this can just be a normal byte string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">&quot;[^01]+&quot;</span>).unwrap();
<span class="macro">assert_eq!</span>(re.replace(<span class="string">b&quot;1078910&quot;</span>, <span class="kw-2">&amp;</span><span class="string">b&quot;&quot;</span>[..]), <span class="kw-2">&amp;</span><span class="string">b&quot;1010&quot;</span>[..]);</code></pre></div>
<p>But anything satisfying the <code>Replacer</code> trait will work. For example, a
closure of type <code>|&amp;Captures| -&gt; Vec&lt;u8&gt;</code> provides direct access to the
captures corresponding to a match. This allows one to access capturing
group matches easily:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r&quot;([^,\s]+),\s+(\S+)&quot;</span>).unwrap();
<span class="kw">let </span>result = re.replace(<span class="string">b&quot;Springsteen, Bruce&quot;</span>, |caps: <span class="kw-2">&amp;</span>Captures| {
    <span class="kw">let </span><span class="kw-2">mut </span>replacement = caps[<span class="number">2</span>].to_owned();
    replacement.push(<span class="string">b&#39; &#39;</span>);
    replacement.extend(<span class="kw-2">&amp;</span>caps[<span class="number">1</span>]);
    replacement
});
<span class="macro">assert_eq!</span>(result, <span class="kw-2">&amp;</span><span class="string">b&quot;Bruce Springsteen&quot;</span>[..]);</code></pre></div>
<p>But this is a bit cumbersome to use all the time. Instead, a simple
syntax is supported that expands <code>$name</code> into the corresponding capture
group. Here’s the last example, but using this expansion technique
with named capture groups:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r&quot;(?P&lt;last&gt;[^,\s]+),\s+(?P&lt;first&gt;\S+)&quot;</span>).unwrap();
<span class="kw">let </span>result = re.replace(<span class="string">b&quot;Springsteen, Bruce&quot;</span>, <span class="kw-2">&amp;</span><span class="string">b&quot;$first $last&quot;</span>[..]);
<span class="macro">assert_eq!</span>(result, <span class="kw-2">&amp;</span><span class="string">b&quot;Bruce Springsteen&quot;</span>[..]);</code></pre></div>
<p>Note that using <code>$2</code> instead of <code>$first</code> or <code>$1</code> instead of <code>$last</code>
would produce the same result. To write a literal <code>$</code> use <code>$$</code>.</p>
<p>Sometimes the replacement string requires use of curly braces to
delineate a capture group replacement and surrounding literal text.
For example, if we wanted to join two words together with an
underscore:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r&quot;(?P&lt;first&gt;\w+)\s+(?P&lt;second&gt;\w+)&quot;</span>).unwrap();
<span class="kw">let </span>result = re.replace(<span class="string">b&quot;deep fried&quot;</span>, <span class="kw-2">&amp;</span><span class="string">b&quot;${first}_$second&quot;</span>[..]);
<span class="macro">assert_eq!</span>(result, <span class="kw-2">&amp;</span><span class="string">b&quot;deep_fried&quot;</span>[..]);</code></pre></div>
<p>Without the curly braces, the capture group name <code>first_</code> would be
used, and since it doesn’t exist, it would be replaced with the empty
string.</p>
<p>Finally, sometimes you just want to replace a literal string with no
regard for capturing group expansion. This can be done by wrapping a
byte string with <code>NoExpand</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::bytes::NoExpand;

<span class="kw">let </span>re = Regex::new(<span class="string">r&quot;(?P&lt;last&gt;[^,\s]+),\s+(\S+)&quot;</span>).unwrap();
<span class="kw">let </span>result = re.replace(<span class="string">b&quot;Springsteen, Bruce&quot;</span>, NoExpand(<span class="string">b&quot;$2 $last&quot;</span>));
<span class="macro">assert_eq!</span>(result, <span class="kw-2">&amp;</span><span class="string">b&quot;$2 $last&quot;</span>[..]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.replace_all" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#471-477">source</a></span><h4 class="code-header">pub fn <a href="#method.replace_all" class="fnname">replace_all</a>&lt;'t, R:&nbsp;<a class="trait" href="trait.Replacer.html" title="trait regex::bytes::Replacer">Replacer</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self,<br>&nbsp;&nbsp;&nbsp;&nbsp;text: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>],<br>&nbsp;&nbsp;&nbsp;&nbsp;rep: R<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'t, [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;</h4></section></summary><div class="docblock"><p>Replaces all non-overlapping matches in <code>text</code> with the replacement
provided. This is the same as calling <code>replacen</code> with <code>limit</code> set to
<code>0</code>.</p>
<p>See the documentation for <code>replace</code> for details on how to access
capturing group matches in the replacement text.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.replacen" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#485-530">source</a></span><h4 class="code-header">pub fn <a href="#method.replacen" class="fnname">replacen</a>&lt;'t, R:&nbsp;<a class="trait" href="trait.Replacer.html" title="trait regex::bytes::Replacer">Replacer</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self,<br>&nbsp;&nbsp;&nbsp;&nbsp;text: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>],<br>&nbsp;&nbsp;&nbsp;&nbsp;limit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;rep: R<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'t, [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;</h4></section></summary><div class="docblock"><p>Replaces at most <code>limit</code> non-overlapping matches in <code>text</code> with the
replacement provided. If <code>limit</code> is 0, then all non-overlapping matches
are replaced.</p>
<p>See the documentation for <code>replace</code> for details on how to access
capturing group matches in the replacement text.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Regex-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#534-651">source</a></span><a href="#impl-Regex-1" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.Regex.html" title="struct regex::bytes::Regex">Regex</a></h3></section></summary><div class="docblock"><p>Advanced or “lower level” search methods.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shortest_match" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#556-558">source</a></span><h4 class="code-header">pub fn <a href="#method.shortest_match" class="fnname">shortest_match</a>(&amp;self, text: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the end location of a match in the text given.</p>
<p>This method may have the same performance characteristics as
<code>is_match</code>, except it provides an end location for a match. In
particular, the location returned <em>may be shorter</em> than the proper end
of the leftmost-first match.</p>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<p>Typically, <code>a+</code> would match the entire first sequence of <code>a</code> in some
text, but <code>shortest_match</code> can give up as soon as it sees the first
<code>a</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">b&quot;aaaaa&quot;</span>;
<span class="kw">let </span>pos = Regex::new(<span class="string">r&quot;a+&quot;</span>).unwrap().shortest_match(text);
<span class="macro">assert_eq!</span>(pos, <span class="prelude-val">Some</span>(<span class="number">1</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shortest_match_at" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#566-572">source</a></span><h4 class="code-header">pub fn <a href="#method.shortest_match_at" class="fnname">shortest_match_at</a>(&amp;self, text: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>], start: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the same as shortest_match, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_match_at" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#580-582">source</a></span><h4 class="code-header">pub fn <a href="#method.is_match_at" class="fnname">is_match_at</a>(&amp;self, text: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>], start: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns the same as is_match, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.find_at" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#590-599">source</a></span><h4 class="code-header">pub fn <a href="#method.find_at" class="fnname">find_at</a>&lt;'t&gt;(&amp;self, text: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>], start: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Match.html" title="struct regex::bytes::Match">Match</a>&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the same as find, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures_read" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#611-617">source</a></span><h4 class="code-header">pub fn <a href="#method.captures_read" class="fnname">captures_read</a>&lt;'t&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self,<br>&nbsp;&nbsp;&nbsp;&nbsp;locs: &amp;mut <a class="struct" href="struct.CaptureLocations.html" title="struct regex::bytes::CaptureLocations">CaptureLocations</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;text: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Match.html" title="struct regex::bytes::Match">Match</a>&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>This is like <code>captures</code>, but uses
<a href="struct.CaptureLocations.html"><code>CaptureLocations</code></a>
instead of
<a href="struct.Captures.html"><code>Captures</code></a> in order to amortize allocations.</p>
<p>To create a <code>CaptureLocations</code> value, use the
<code>Regex::capture_locations</code> method.</p>
<p>This returns the overall match if this was successful, which is always
equivalence to the <code>0</code>th capture group.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures_read_at" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#625-635">source</a></span><h4 class="code-header">pub fn <a href="#method.captures_read_at" class="fnname">captures_read_at</a>&lt;'t&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self,<br>&nbsp;&nbsp;&nbsp;&nbsp;locs: &amp;mut <a class="struct" href="struct.CaptureLocations.html" title="struct regex::bytes::CaptureLocations">CaptureLocations</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;text: &amp;'t [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>],<br>&nbsp;&nbsp;&nbsp;&nbsp;start: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Match.html" title="struct regex::bytes::Match">Match</a>&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the same as <code>captures_read</code>, but starts the search at the given
offset and populates the capture locations given.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Regex-2" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#654-684">source</a></span><a href="#impl-Regex-2" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.Regex.html" title="struct regex::bytes::Regex">Regex</a></h3></section></summary><div class="docblock"><p>Auxiliary methods.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_str" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#656-658">source</a></span><h4 class="code-header">pub fn <a href="#method.as_str" class="fnname">as_str</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns the original string of this regex.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.capture_names" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#661-663">source</a></span><h4 class="code-header">pub fn <a href="#method.capture_names" class="fnname">capture_names</a>(&amp;self) -&gt; <a class="struct" href="struct.CaptureNames.html" title="struct regex::bytes::CaptureNames">CaptureNames</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="struct.CaptureNames.html" title="struct regex::bytes::CaptureNames">CaptureNames</a>&lt;'r&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'r&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="struct.CaptureNames.html" title="struct regex::bytes::CaptureNames">CaptureNames</a>&lt;'r&gt;</span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'r <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Returns an iterator over the capture names.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures_len" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#666-668">source</a></span><h4 class="code-header">pub fn <a href="#method.captures_len" class="fnname">captures_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of captures.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.capture_locations" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#672-674">source</a></span><h4 class="code-header">pub fn <a href="#method.capture_locations" class="fnname">capture_locations</a>(&amp;self) -&gt; <a class="struct" href="struct.CaptureLocations.html" title="struct regex::bytes::CaptureLocations">CaptureLocations</a></h4></section></summary><div class="docblock"><p>Returns an empty set of capture locations that can be reused in
multiple calls to <code>captures_read</code> or <code>captures_read_at</code>.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Clone-for-Regex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#77">source</a></span><a href="#impl-Clone-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Regex.html" title="struct regex::bytes::Regex">Regex</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#77">source</a></span><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Regex.html" title="struct regex::bytes::Regex">Regex</a></h4></section></summary><div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#132-134">source</a></span><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug-for-Regex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#87-92">source</a></span><a href="#impl-Debug-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Regex.html" title="struct regex::bytes::Regex">Regex</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#89-91">source</a></span><a href="#method.fmt-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class="docblock"><p>Shows the original regular expression.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Display-for-Regex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#80-85">source</a></span><a href="#impl-Display-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.Regex.html" title="struct regex::bytes::Regex">Regex</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#82-84">source</a></span><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class="docblock"><p>Shows the original regular expression.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-FromStr-for-Regex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#104-111">source</a></span><a href="#impl-FromStr-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a> for <a class="struct" href="struct.Regex.html" title="struct regex::bytes::Regex">Regex</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_str" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/regex/re_bytes.rs.html#108-110">source</a></span><a href="#method.from_str" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html#tymethod.from_str" class="fnname">from_str</a>(s: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Regex.html" title="struct regex::bytes::Regex">Regex</a>, <a class="enum" href="../enum.Error.html" title="enum regex::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Attempts to parse a string into a regular expression</p>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Err" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Err" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html#associatedtype.Err" class="associatedtype">Err</a> = <a class="enum" href="../enum.Error.html" title="enum regex::Error">Error</a></h4></section></summary><div class='docblock'><p>The associated error which can be returned from parsing.</p>
</div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Regex" class="impl has-srclink"><a href="#impl-RefUnwindSafe-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Regex.html" title="struct regex::bytes::Regex">Regex</a></h3></section><section id="impl-Send-for-Regex" class="impl has-srclink"><a href="#impl-Send-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Regex.html" title="struct regex::bytes::Regex">Regex</a></h3></section><section id="impl-Sync-for-Regex" class="impl has-srclink"><a href="#impl-Sync-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Regex.html" title="struct regex::bytes::Regex">Regex</a></h3></section><section id="impl-Unpin-for-Regex" class="impl has-srclink"><a href="#impl-Unpin-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Regex.html" title="struct regex::bytes::Regex">Regex</a></h3></section><section id="impl-UnwindSafe-for-Regex" class="impl has-srclink"><a href="#impl-UnwindSafe-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Regex.html" title="struct regex::bytes::Regex">Regex</a></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any-for-Regex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#203">source</a></span><a href="#impl-Any-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#204">source</a></span><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-Regex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209">source</a></span><a href="#impl-Borrow%3CT%3E-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-Regex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218">source</a></span><a href="#impl-BorrowMut%3CT%3E-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-Regex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#557">source</a></span><a href="#impl-From%3CT%3E-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#559">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-Regex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#541">source</a></span><a href="#impl-Into%3CU%3E-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#549">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToOwned-for-Regex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#83">source</a></span><a href="#impl-ToOwned-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#88">source</a></span><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#92">source</a></span><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</h4></section></summary><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToString-for-Regex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2479">source</a></span><a href="#impl-ToString-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2485">source</a></span><a href="#method.to_string" class="anchor"></a><h4 class="code-header">default fn <a href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html#tymethod.to_string" class="fnname">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'><p>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-Regex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#598">source</a></span><a href="#impl-TryFrom%3CU%3E-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#604">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-Regex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#583">source</a></span><a href="#impl-TryInto%3CU%3E-for-Regex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#589">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="regex" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0-nightly (c0941dfb5 2022-08-21)" ></div></body></html>