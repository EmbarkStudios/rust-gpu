<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `SparseDFA` enum in crate `regex_automata`."><meta name="keywords" content="rust, rustlang, rust-lang, SparseDFA"><title>regex_automata::SparseDFA - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc enum"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../regex_automata/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Enum SparseDFA</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#variants">Variants</a><div class="sidebar-links"><a href="#variant.ByteClass">ByteClass</a><a href="#variant.Standard">Standard</a></div><a class="sidebar-title" href="#implementations">Methods</a><div class="sidebar-links"><a href="#method.as_ref">as_ref</a><a href="#method.empty">empty</a><a href="#method.from_bytes">from_bytes</a><a href="#method.memory_usage">memory_usage</a><a href="#method.new">new</a><a href="#method.to_bytes_big_endian">to_bytes_big_endian</a><a href="#method.to_bytes_little_endian">to_bytes_little_endian</a><a href="#method.to_bytes_native_endian">to_bytes_native_endian</a><a href="#method.to_owned">to_owned</a><a href="#method.to_sized">to_sized</a><a href="#method.to_u16">to_u16</a><a href="#method.to_u32">to_u32</a><a href="#method.to_u64">to_u64</a><a href="#method.to_u8">to_u8</a></div><a class="sidebar-title" href="#trait-implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-DFA">DFA</a><a href="#impl-Debug">Debug</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-RefUnwindSafe">RefUnwindSafe</a><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">UnwindSafe</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><p class="location"><a href="index.html">regex_automata</a></p><script>window.sidebarCurrent = {name: "SparseDFA", ty: "enum", relpath: ""};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/regex_automata/sparse.rs.html#109-131" title="goto source code">[src]</a></span><span class="in-band">Enum <a href="index.html">regex_automata</a>::<wbr><a class="enum" href="">SparseDFA</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class="rust enum">pub enum SparseDFA&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;, S:&nbsp;<a class="trait" href="../regex_automata/trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&nbsp;=&nbsp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; {
    Standard(<a class="struct" href="../regex_automata/sparse/struct.Standard.html" title="struct regex_automata::sparse::Standard">Standard</a>&lt;T, S&gt;),
    ByteClass(<a class="struct" href="../regex_automata/sparse/struct.ByteClass.html" title="struct regex_automata::sparse::ByteClass">ByteClass</a>&lt;T, S&gt;),
    // some variants omitted
}</pre></div><div class="docblock"><p>A sparse table-based deterministic finite automaton (DFA).</p>
<p>In contrast to a <a href="enum.DenseDFA.html">dense DFA</a>, a sparse DFA uses a
more space efficient representation for its transition table. Consequently,
sparse DFAs can use much less memory than dense DFAs, but this comes at a
price. In particular, reading the more space efficient transitions takes
more work, and consequently, searching using a sparse DFA is typically
slower than a dense DFA.</p>
<p>A sparse DFA can be built using the default configuration via the
<a href="enum.SparseDFA.html#method.new"><code>SparseDFA::new</code></a> constructor. Otherwise,
one can configure various aspects of a dense DFA via
<a href="dense/struct.Builder.html"><code>dense::Builder</code></a>, and then convert a dense
DFA to a sparse DFA using
<a href="enum.DenseDFA.html#method.to_sparse"><code>DenseDFA::to_sparse</code></a>.</p>
<p>In general, a sparse DFA supports all the same operations as a dense DFA.</p>
<p>Making the choice between a dense and sparse DFA depends on your specific
work load. If you can sacrifice a bit of search time performance, then a
sparse DFA might be the best choice. In particular, while sparse DFAs are
probably always slower than dense DFAs, you may find that they are easily
fast enough for your purposes!</p>
<h1 id="state-size" class="section-header"><a href="#state-size">State size</a></h1>
<p>A <code>SparseDFA</code> has two type parameters, <code>T</code> and <code>S</code>. <code>T</code> corresponds to
the type of the DFA's transition table while <code>S</code> corresponds to the
representation used for the DFA's state identifiers as described by the
<a href="trait.StateID.html"><code>StateID</code></a> trait. This type parameter is typically
<code>usize</code>, but other valid choices provided by this crate include <code>u8</code>,
<code>u16</code>, <code>u32</code> and <code>u64</code>. The primary reason for choosing a different state
identifier representation than the default is to reduce the amount of
memory used by a DFA. Note though, that if the chosen representation cannot
accommodate the size of your DFA, then building the DFA will fail and
return an error.</p>
<p>While the reduction in heap memory used by a DFA is one reason for choosing
a smaller state identifier representation, another possible reason is for
decreasing the serialization size of a DFA, as returned by
<a href="enum.SparseDFA.html#method.to_bytes_little_endian"><code>to_bytes_little_endian</code></a>,
<a href="enum.SparseDFA.html#method.to_bytes_big_endian"><code>to_bytes_big_endian</code></a>
or
<a href="enum.DenseDFA.html#method.to_bytes_native_endian"><code>to_bytes_native_endian</code></a>.</p>
<p>The type of the transition table is typically either <code>Vec&lt;u8&gt;</code> or <code>&amp;[u8]</code>,
depending on where the transition table is stored. Note that this is
different than a dense DFA, whose transition table is typically
<code>Vec&lt;S&gt;</code> or <code>&amp;[S]</code>. The reason for this is that a sparse DFA always reads
its transition table from raw bytes because the table is compactly packed.</p>
<h1 id="variants-1" class="section-header"><a href="#variants-1">Variants</a></h1>
<p>This DFA is defined as a non-exhaustive enumeration of different types of
dense DFAs. All of the variants use the same internal representation
for the transition table, but they vary in how the transition table is
read. A DFA's specific variant depends on the configuration options set via
<a href="dense/struct.Builder.html"><code>dense::Builder</code></a>. The default variant is
<code>ByteClass</code>.</p>
<h1 id="the-dfa-trait" class="section-header"><a href="#the-dfa-trait">The <code>DFA</code> trait</a></h1>
<p>This type implements the <a href="trait.DFA.html"><code>DFA</code></a> trait, which means it
can be used for searching. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">DFA</span>, <span class="ident">SparseDFA</span>};

<span class="kw">let</span> <span class="ident">dfa</span> <span class="op">=</span> <span class="ident">SparseDFA</span>::<span class="ident">new</span>(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">8</span>), <span class="ident">dfa</span>.<span class="ident">find</span>(<span class="string">b&quot;foo12345&quot;</span>));</pre></div>
<p>The <code>DFA</code> trait also provides an assortment of other lower level methods
for DFAs, such as <code>start_state</code> and <code>next_state</code>. While these are correctly
implemented, it is an anti-pattern to use them in performance sensitive
code on the <code>SparseDFA</code> type directly. Namely, each implementation requires
a branch to determine which type of sparse DFA is being used. Instead,
this branch should be pushed up a layer in the code since walking the
transitions of a DFA is usually a hot path. If you do need to use these
lower level methods in performance critical code, then you should match on
the variants of this DFA and use each variant's implementation of the <code>DFA</code>
trait directly.</p>
</div><h2 id="variants" class="variants small-section-header">
                   Variants<a href="#variants" class="anchor"></a></h2>
<div id="variant.Standard" class="variant small-section-header"><a href="#variant.Standard" class="anchor field"></a><code>Standard(<a class="struct" href="../regex_automata/sparse/struct.Standard.html" title="struct regex_automata::sparse::Standard">Standard</a>&lt;T, S&gt;)</code></div><div class="docblock"><p>A standard DFA that does not use byte classes.</p>
</div><div id="variant.ByteClass" class="variant small-section-header"><a href="#variant.ByteClass" class="anchor field"></a><code>ByteClass(<a class="struct" href="../regex_automata/sparse/struct.ByteClass.html" title="struct regex_automata::sparse::ByteClass">ByteClass</a>&lt;T, S&gt;)</code></div><div class="docblock"><p>A DFA that shrinks its alphabet to a set of equivalence classes instead
of using all possible byte values. Any two bytes belong to the same
equivalence class if and only if they can be used interchangeably
anywhere in the DFA while never discriminating between a match and a
non-match.</p>
<p>Unlike dense DFAs, sparse DFAs do not tend to benefit nearly as much
from using byte classes. In some cases, using byte classes can even
marginally increase the size of a sparse DFA's transition table. The
reason for this is that a sparse DFA already compacts each state's
transitions separate from whether byte classes are used.</p>
</div><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><h3 id="impl" class="impl"><code class="in-band">impl <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a href="#impl" class="anchor"></a><a class="srclink" href="../src/regex_automata/sparse.rs.html#134-163" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.new" class="method"><code>pub fn <a href="#method.new" class="fnname">new</a>(pattern: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;, <a class="struct" href="../regex_automata/struct.Error.html" title="struct regex_automata::Error">Error</a>&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#158-162" title="goto source code">[src]</a></h4><div class="docblock"><p>Parse the given regular expression using a default configuration and
return the corresponding sparse DFA.</p>
<p>The default configuration uses <code>usize</code> for state IDs and reduces the
alphabet size by splitting bytes into equivalence classes. The
resulting DFA is <em>not</em> minimized.</p>
<p>If you want a non-default configuration, then use the
<a href="dense/struct.Builder.html"><code>dense::Builder</code></a>
to set your own configuration, and then call
<a href="enum.DenseDFA.html#method.to_sparse"><code>DenseDFA::to_sparse</code></a>
to create a sparse DFA.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">DFA</span>, <span class="ident">SparseDFA</span>};

<span class="kw">let</span> <span class="ident">dfa</span> <span class="op">=</span> <span class="ident">SparseDFA</span>::<span class="ident">new</span>(<span class="string">&quot;foo[0-9]+bar&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">11</span>), <span class="ident">dfa</span>.<span class="ident">find</span>(<span class="string">b&quot;foo12345bar&quot;</span>));</pre></div>
</div></div><h3 id="impl-1" class="impl"><code class="in-band">impl&lt;S:&nbsp;<a class="trait" href="../regex_automata/trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;, S&gt;</code><a href="#impl-1" class="anchor"></a><a class="srclink" href="../src/regex_automata/sparse.rs.html#166-192" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.empty" class="method"><code>pub fn <a href="#method.empty" class="fnname">empty</a>() -&gt; <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;, S&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#183-185" title="goto source code">[src]</a></h4><div class="docblock"><p>Create a new empty sparse DFA that never matches any input.</p>
<h1 id="example-1" class="section-header"><a href="#example-1">Example</a></h1>
<p>In order to build an empty DFA, callers must provide a type hint
indicating their choice of state identifier representation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">DFA</span>, <span class="ident">SparseDFA</span>};

<span class="kw">let</span> <span class="ident">dfa</span>: <span class="ident">SparseDFA</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>, <span class="ident">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">SparseDFA</span>::<span class="ident">empty</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">dfa</span>.<span class="ident">find</span>(<span class="string">b&quot;&quot;</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">dfa</span>.<span class="ident">find</span>(<span class="string">b&quot;foo&quot;</span>));</pre></div>
</div></div><h3 id="impl-2" class="impl"><code class="in-band">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;, S:&nbsp;<a class="trait" href="../regex_automata/trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;T, S&gt;</code><a href="#impl-2" class="anchor"></a><a class="srclink" href="../src/regex_automata/sparse.rs.html#194-248" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.as_ref" class="method"><code>pub fn <a href="#method.as_ref" class="fnname">as_ref</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, S&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#198-208" title="goto source code">[src]</a></h4><div class="docblock"><p>Cheaply return a borrowed version of this sparse DFA. Specifically, the
DFA returned always uses <code>&amp;[u8]</code> for its transition table while keeping
the same state identifier representation.</p>
</div><h4 id="method.to_owned" class="method"><code>pub fn <a href="#method.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;, S&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#217-227" title="goto source code">[src]</a></h4><div class="docblock"><p>Return an owned version of this sparse DFA. Specifically, the DFA
returned always uses <code>Vec&lt;u8&gt;</code> for its transition table while keeping
the same state identifier representation.</p>
<p>Effectively, this returns a sparse DFA whose transition table lives
on the heap.</p>
</div><h4 id="method.memory_usage" class="method"><code>pub fn <a href="#method.memory_usage" class="fnname">memory_usage</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class="srclink" href="../src/regex_automata/sparse.rs.html#237-239" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the memory usage, in bytes, of this DFA.</p>
<p>The memory usage is computed based on the number of bytes used to
represent this DFA's transition table. This typically corresponds to
heap memory usage.</p>
<p>This does <strong>not</strong> include the stack size used up by this DFA. To
compute that, used <code>std::mem::size_of::&lt;SparseDFA&gt;()</code>.</p>
</div></div><h3 id="impl-3" class="impl"><code class="in-band">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;, S:&nbsp;<a class="trait" href="../regex_automata/trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;T, S&gt;</code><a href="#impl-3" class="anchor"></a><a class="srclink" href="../src/regex_automata/sparse.rs.html#253-343" title="goto source code">[src]</a></h3><div class="docblock"><p>Routines for converting a sparse DFA to other representations, such as
smaller state identifiers or raw bytes suitable for persistent storage.</p>
</div><div class="impl-items"><h4 id="method.to_u8" class="method"><code>pub fn <a href="#method.to_u8" class="fnname">to_u8</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;, <a class="struct" href="../regex_automata/struct.Error.html" title="struct regex_automata::Error">Error</a>&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#260-262" title="goto source code">[src]</a></h4><div class="docblock"><p>Create a new sparse DFA whose match semantics are equivalent to
this DFA, but attempt to use <code>u8</code> for the representation of state
identifiers. If <code>u8</code> is insufficient to represent all state identifiers
in this DFA, then this returns an error.</p>
<p>This is a convenience routine for <code>to_sized::&lt;u8&gt;()</code>.</p>
</div><h4 id="method.to_u16" class="method"><code>pub fn <a href="#method.to_u16" class="fnname">to_u16</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u16.html">u16</a>&gt;, <a class="struct" href="../regex_automata/struct.Error.html" title="struct regex_automata::Error">Error</a>&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#270-272" title="goto source code">[src]</a></h4><div class="docblock"><p>Create a new sparse DFA whose match semantics are equivalent to
this DFA, but attempt to use <code>u16</code> for the representation of state
identifiers. If <code>u16</code> is insufficient to represent all state
identifiers in this DFA, then this returns an error.</p>
<p>This is a convenience routine for <code>to_sized::&lt;u16&gt;()</code>.</p>
</div><h4 id="method.to_u32" class="method"><code>pub fn <a href="#method.to_u32" class="fnname">to_u32</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;, <a class="struct" href="../regex_automata/struct.Error.html" title="struct regex_automata::Error">Error</a>&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#281-283" title="goto source code">[src]</a></h4><div class="docblock"><p>Create a new sparse DFA whose match semantics are equivalent to
this DFA, but attempt to use <code>u32</code> for the representation of state
identifiers. If <code>u32</code> is insufficient to represent all state
identifiers in this DFA, then this returns an error.</p>
<p>This is a convenience routine for <code>to_sized::&lt;u32&gt;()</code>.</p>
</div><h4 id="method.to_u64" class="method"><code>pub fn <a href="#method.to_u64" class="fnname">to_u64</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;, <a class="struct" href="../regex_automata/struct.Error.html" title="struct regex_automata::Error">Error</a>&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#292-294" title="goto source code">[src]</a></h4><div class="docblock"><p>Create a new sparse DFA whose match semantics are equivalent to
this DFA, but attempt to use <code>u64</code> for the representation of state
identifiers. If <code>u64</code> is insufficient to represent all state
identifiers in this DFA, then this returns an error.</p>
<p>This is a convenience routine for <code>to_sized::&lt;u64&gt;()</code>.</p>
</div><h4 id="method.to_sized" class="method"><code>pub fn <a href="#method.to_sized" class="fnname">to_sized</a>&lt;A:&nbsp;<a class="trait" href="../regex_automata/trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt;(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;, A&gt;, <a class="struct" href="../regex_automata/struct.Error.html" title="struct regex_automata::Error">Error</a>&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#306-308" title="goto source code">[src]</a></h4><div class="docblock"><p>Create a new sparse DFA whose match semantics are equivalent to
this DFA, but attempt to use <code>A</code> for the representation of state
identifiers. If <code>A</code> is insufficient to represent all state identifiers
in this DFA, then this returns an error.</p>
<p>An alternative way to construct such a DFA is to use
<a href="enum.DenseDFA.html#method.to_sparse_sized"><code>DenseDFA::to_sparse_sized</code></a>.
In general, picking the appropriate size upon initial construction of
a sparse DFA is preferred, since it will do the conversion in one
step instead of two.</p>
</div><h4 id="method.to_bytes_little_endian" class="method"><code>pub fn <a href="#method.to_bytes_little_endian" class="fnname">to_bytes_little_endian</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;, <a class="struct" href="../regex_automata/struct.Error.html" title="struct regex_automata::Error">Error</a>&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#316-318" title="goto source code">[src]</a></h4><div class="docblock"><p>Serialize a sparse DFA to raw bytes in little endian format.</p>
<p>If the state identifier representation of this DFA has a size different
than 1, 2, 4 or 8 bytes, then this returns an error. All
implementations of <code>StateID</code> provided by this crate satisfy this
requirement.</p>
</div><h4 id="method.to_bytes_big_endian" class="method"><code>pub fn <a href="#method.to_bytes_big_endian" class="fnname">to_bytes_big_endian</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;, <a class="struct" href="../regex_automata/struct.Error.html" title="struct regex_automata::Error">Error</a>&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#326-328" title="goto source code">[src]</a></h4><div class="docblock"><p>Serialize a sparse DFA to raw bytes in big endian format.</p>
<p>If the state identifier representation of this DFA has a size different
than 1, 2, 4 or 8 bytes, then this returns an error. All
implementations of <code>StateID</code> provided by this crate satisfy this
requirement.</p>
</div><h4 id="method.to_bytes_native_endian" class="method"><code>pub fn <a href="#method.to_bytes_native_endian" class="fnname">to_bytes_native_endian</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;, <a class="struct" href="../regex_automata/struct.Error.html" title="struct regex_automata::Error">Error</a>&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#340-342" title="goto source code">[src]</a></h4><div class="docblock"><p>Serialize a sparse DFA to raw bytes in native endian format.
Generally, it is better to pick an explicit endianness using either
<code>to_bytes_little_endian</code> or <code>to_bytes_big_endian</code>. This routine is
useful in tests where the DFA is serialized and deserialized on the
same platform.</p>
<p>If the state identifier representation of this DFA has a size different
than 1, 2, 4 or 8 bytes, then this returns an error. All
implementations of <code>StateID</code> provided by this crate satisfy this
requirement.</p>
</div></div><h3 id="impl-4" class="impl"><code class="in-band">impl&lt;'a, S:&nbsp;<a class="trait" href="../regex_automata/trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, S&gt;</code><a href="#impl-4" class="anchor"></a><a class="srclink" href="../src/regex_automata/sparse.rs.html#345-413" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from_bytes" class="method"><code>pub unsafe fn <a href="#method.from_bytes" class="fnname">from_bytes</a>(buf: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'a [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, S&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#410-412" title="goto source code">[src]</a></h4><div class="docblock"><p>Deserialize a sparse DFA with a specific state identifier
representation.</p>
<p>Deserializing a DFA using this routine will never allocate heap memory.
This is also guaranteed to be a constant time operation that does not
vary with the size of the DFA.</p>
<p>The bytes given should be generated by the serialization of a DFA with
either the
<a href="enum.DenseDFA.html#method.to_bytes_little_endian"><code>to_bytes_little_endian</code></a>
method or the
<a href="enum.DenseDFA.html#method.to_bytes_big_endian"><code>to_bytes_big_endian</code></a>
endian, depending on the endianness of the machine you are
deserializing this DFA from.</p>
<p>If the state identifier representation is <code>usize</code>, then deserialization
is dependent on the pointer size. For this reason, it is best to
serialize DFAs using a fixed size representation for your state
identifiers, such as <code>u8</code>, <code>u16</code>, <code>u32</code> or <code>u64</code>.</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>The bytes given should be <em>trusted</em>. In particular, if the bytes
are not a valid serialization of a DFA, or if the endianness of the
serialized bytes is different than the endianness of the machine that
is deserializing the DFA, then this routine will panic. Moreover, it
is possible for this deserialization routine to succeed even if the
given bytes do not represent a valid serialized sparse DFA.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>This routine is unsafe because it permits callers to provide an
arbitrary transition table with possibly incorrect transitions. While
the various serialization routines will never return an incorrect
transition table, there is no guarantee that the bytes provided here
are correct. While deserialization does many checks (as documented
above in the panic conditions), this routine does not check that the
transition table is correct. Given an incorrect transition table, it is
possible for the search routines to access out-of-bounds memory because
of explicit bounds check elision.</p>
<h1 id="example-2" class="section-header"><a href="#example-2">Example</a></h1>
<p>This example shows how to serialize a DFA to raw bytes, deserialize it
and then use it for searching. Note that we first convert the DFA to
using <code>u16</code> for its state identifier representation before serializing
it. While this isn't strictly necessary, it's good practice in order to
decrease the size of the DFA and to avoid platform specific pitfalls
such as differing pointer sizes.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">regex_automata</span>::{<span class="ident">DFA</span>, <span class="ident">DenseDFA</span>, <span class="ident">SparseDFA</span>};

<span class="kw">let</span> <span class="ident">sparse</span> <span class="op">=</span> <span class="ident">SparseDFA</span>::<span class="ident">new</span>(<span class="string">&quot;foo[0-9]+&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="ident">sparse</span>.<span class="ident">to_u16</span>()<span class="question-mark">?</span>.<span class="ident">to_bytes_native_endian</span>()<span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">dfa</span>: <span class="ident">SparseDFA</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">u16</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="ident">SparseDFA</span>::<span class="ident">from_bytes</span>(<span class="kw-2">&amp;</span><span class="ident">bytes</span>)
};

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">8</span>), <span class="ident">dfa</span>.<span class="ident">find</span>(<span class="string">b&quot;foo12345&quot;</span>));</pre></div>
</div></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><h3 id="impl-Clone" class="impl"><code class="in-band">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;, S:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="../regex_automata/trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;T, S&gt;</code><a href="#impl-Clone" class="anchor"></a><a class="srclink" href="../src/regex_automata/sparse.rs.html#108" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.clone" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;T, S&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#108" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id="method.clone_from" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#128-130" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 id="impl-DFA" class="impl"><code class="in-band">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;, S:&nbsp;<a class="trait" href="../regex_automata/trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="../regex_automata/trait.DFA.html" title="trait regex_automata::DFA">DFA</a> for <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;T, S&gt;</code><a href="#impl-DFA" class="anchor"></a><a class="srclink" href="../src/regex_automata/sparse.rs.html#415-499" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.ID" class="type"><code>type <a href="../regex_automata/trait.DFA.html#associatedtype.ID" class="type">ID</a> = S</code></h4><div class='docblock'><p>The representation used for state identifiers in this DFA. <a href="../regex_automata/trait.DFA.html#associatedtype.ID">Read more</a></p>
</div><h4 id="method.start_state" class="method hidden"><code>fn <a href="../regex_automata/trait.DFA.html#tymethod.start_state" class="fnname">start_state</a>(&amp;self) -&gt; S</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#419-421" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Return the identifier of this DFA's start state.</p>
</div><h4 id="method.is_match_state" class="method hidden"><code>fn <a href="../regex_automata/trait.DFA.html#tymethod.is_match_state" class="fnname">is_match_state</a>(&amp;self, id: S) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/regex_automata/sparse.rs.html#424-426" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns true if and only if the given identifier corresponds to a match
state. <a href="../regex_automata/trait.DFA.html#tymethod.is_match_state">Read more</a></p>
</div><h4 id="method.is_dead_state" class="method hidden"><code>fn <a href="../regex_automata/trait.DFA.html#tymethod.is_dead_state" class="fnname">is_dead_state</a>(&amp;self, id: S) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/regex_automata/sparse.rs.html#429-431" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns true if and only if the given identifier corresponds to a dead
state. When a DFA enters a dead state, it is impossible to leave and
thus can never lead to a match. <a href="../regex_automata/trait.DFA.html#tymethod.is_dead_state">Read more</a></p>
</div><h4 id="method.is_match_or_dead_state" class="method hidden"><code>fn <a href="../regex_automata/trait.DFA.html#tymethod.is_match_or_dead_state" class="fnname">is_match_or_dead_state</a>(&amp;self, id: S) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/regex_automata/sparse.rs.html#434-436" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns true if and only if the given identifier corresponds to either
a dead state or a match state, such that one of <code>is_match_state(id)</code>
or <code>is_dead_state(id)</code> must return true. <a href="../regex_automata/trait.DFA.html#tymethod.is_match_or_dead_state">Read more</a></p>
</div><h4 id="method.is_anchored" class="method hidden"><code>fn <a href="../regex_automata/trait.DFA.html#tymethod.is_anchored" class="fnname">is_anchored</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/regex_automata/sparse.rs.html#439-441" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns true if and only if this DFA is anchored. <a href="../regex_automata/trait.DFA.html#tymethod.is_anchored">Read more</a></p>
</div><h4 id="method.next_state" class="method hidden"><code>fn <a href="../regex_automata/trait.DFA.html#tymethod.next_state" class="fnname">next_state</a>(&amp;self, current: S, input: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>) -&gt; S</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#444-450" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Given the current state that this DFA is in and the next input byte,
this method returns the identifier of the next state. The identifier
returned is always valid, but it may correspond to a dead state. <a href="../regex_automata/trait.DFA.html#tymethod.next_state">Read more</a></p>
</div><h4 id="method.next_state_unchecked" class="method hidden"><code>unsafe fn <a href="../regex_automata/trait.DFA.html#tymethod.next_state_unchecked" class="fnname">next_state_unchecked</a>(&amp;self, current: S, input: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>) -&gt; S</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#453-455" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Like <code>next_state</code>, but its implementation may look up the next state
without memory safety checks such as bounds checks. As such, callers
must ensure that the given identifier corresponds to a valid DFA
state. Implementors must, in turn, ensure that this routine is safe
for all valid state identifiers and for all possible <code>u8</code> values. <a href="../regex_automata/trait.DFA.html#tymethod.next_state_unchecked">Read more</a></p>
</div><h4 id="method.is_match_at" class="method hidden"><code>fn <a href="../regex_automata/trait.DFA.html#method.is_match_at" class="fnname">is_match_at</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, start: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/regex_automata/sparse.rs.html#465-471" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns the same as <code>is_match</code>, but starts the search at the given
offset. <a href="../regex_automata/trait.DFA.html#method.is_match_at">Read more</a></p>
</div><h4 id="method.shortest_match_at" class="method hidden"><code>fn <a href="../regex_automata/trait.DFA.html#method.shortest_match_at" class="fnname">shortest_match_at</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, start: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#474-480" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns the same as <code>shortest_match</code>, but starts the search at the
given offset. <a href="../regex_automata/trait.DFA.html#method.shortest_match_at">Read more</a></p>
</div><h4 id="method.find_at" class="method hidden"><code>fn <a href="../regex_automata/trait.DFA.html#method.find_at" class="fnname">find_at</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, start: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#483-489" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns the same as <code>find</code>, but starts the search at the given
offset. <a href="../regex_automata/trait.DFA.html#method.find_at">Read more</a></p>
</div><h4 id="method.rfind_at" class="method hidden"><code>fn <a href="../regex_automata/trait.DFA.html#method.rfind_at" class="fnname">rfind_at</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>, start: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class="srclink" href="../src/regex_automata/sparse.rs.html#492-498" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns the same as <code>rfind</code>, but starts the search at the given
offset. <a href="../regex_automata/trait.DFA.html#method.rfind_at">Read more</a></p>
</div><h4 id="method.is_match" class="method hidden"><code>fn <a href="../regex_automata/trait.DFA.html#method.is_match" class="fnname">is_match</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class="srclink" href="../src/regex_automata/dfa.rs.html#91-93" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns true if and only if the given bytes match this DFA. <a href="../regex_automata/trait.DFA.html#method.is_match">Read more</a></p>
</div><h4 id="method.shortest_match" class="method hidden"><code>fn <a href="../regex_automata/trait.DFA.html#method.shortest_match" class="fnname">shortest_match</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class="srclink" href="../src/regex_automata/dfa.rs.html#121-123" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns the first position at which a match is found. <a href="../regex_automata/trait.DFA.html#method.shortest_match">Read more</a></p>
</div><h4 id="method.find" class="method hidden"><code>fn <a href="../regex_automata/trait.DFA.html#method.find" class="fnname">find</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class="srclink" href="../src/regex_automata/dfa.rs.html#171-173" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns the end offset of the longest match. If no match exists,
then <code>None</code> is returned. <a href="../regex_automata/trait.DFA.html#method.find">Read more</a></p>
</div><h4 id="method.rfind" class="method hidden"><code>fn <a href="../regex_automata/trait.DFA.html#method.rfind" class="fnname">rfind</a>(&amp;self, bytes: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class="srclink" href="../src/regex_automata/dfa.rs.html#199-201" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns the start offset of the longest match in reverse, by searching
from the end of the input towards the start of the input. If no match
exists, then <code>None</code> is returned. In other words, this has the same
match semantics as <code>find</code>, but in reverse. <a href="../regex_automata/trait.DFA.html#method.rfind">Read more</a></p>
</div></div><h3 id="impl-Debug" class="impl"><code class="in-band">impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;, S:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> + <a class="trait" href="../regex_automata/trait.StateID.html" title="trait regex_automata::StateID">StateID</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;T, S&gt;</code><a href="#impl-Debug" class="anchor"></a><a class="srclink" href="../src/regex_automata/sparse.rs.html#108" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.fmt" class="method hidden"><code>fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class="srclink" href="../src/regex_automata/sparse.rs.html#108" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><h3 id="impl-RefUnwindSafe" class="impl"><code class="in-band">impl&lt;T, S&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;T, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></code><a href="#impl-RefUnwindSafe" class="anchor"></a></h3><div class="impl-items"></div><h3 id="impl-Send" class="impl"><code class="in-band">impl&lt;T, S&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;T, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></code><a href="#impl-Send" class="anchor"></a></h3><div class="impl-items"></div><h3 id="impl-Sync" class="impl"><code class="in-band">impl&lt;T, S&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;T, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,&nbsp;</span></code><a href="#impl-Sync" class="anchor"></a></h3><div class="impl-items"></div><h3 id="impl-Unpin" class="impl"><code class="in-band">impl&lt;T, S&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;T, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,&nbsp;</span></code><a href="#impl-Unpin" class="anchor"></a></h3><div class="impl-items"></div><h3 id="impl-UnwindSafe" class="impl"><code class="in-band">impl&lt;T, S&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="enum" href="../regex_automata/enum.SparseDFA.html" title="enum regex_automata::SparseDFA">SparseDFA</a>&lt;T, S&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a>,&nbsp;</span></code><a href="#impl-UnwindSafe" class="anchor"></a></h3><div class="impl-items"></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><h3 id="impl-Any" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Any" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#108-112" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.type_id" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#109-111" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id="impl-Borrow%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Borrow%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210-214" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211-213" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id="impl-BorrowMut%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217-221" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.borrow_mut" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218-220" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id="impl-From%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href="#impl-From%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#552-556" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#553-555" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-Into%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-Into%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#541-548" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="method.into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#545-547" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-ToOwned" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><a href="#impl-ToOwned" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#80-92" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Owned" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</code></h4><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div><h4 id="method.to_owned-1" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#85-87" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div><h4 id="method.clone_into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89-91" title="goto source code">[src]</a></h4><div class="stability hidden"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</summary><p>recently added</p>
</details></div></div><div class='docblock hidden'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></div><h3 id="impl-TryFrom%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#589-598" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#595-597" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id="impl-TryInto%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryInto%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#575-584" title="goto source code">[src]</a></h3><div class="impl-items"><h4 id="associatedtype.Error-1" class="type"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_into" class="method hidden"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#581-583" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "regex_automata";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>