<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A type that collects various properties of an HIR value."><title>Properties in regex_syntax::hir - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-fa3bb1812debf86c.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="regex_syntax" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.0-nightly (8ce4540bd 2023-09-29)" data-channel="nightly" data-search-js="search-8be46b629f5f14a8.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-c5bd66d33317d69f.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../regex_syntax/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a></nav><nav class="sidebar"><a class="logo-container" href="../../regex_syntax/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Properties</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.explicit_captures_len">explicit_captures_len</a></li><li><a href="#method.is_alternation_literal">is_alternation_literal</a></li><li><a href="#method.is_literal">is_literal</a></li><li><a href="#method.is_utf8">is_utf8</a></li><li><a href="#method.look_set">look_set</a></li><li><a href="#method.look_set_prefix">look_set_prefix</a></li><li><a href="#method.look_set_prefix_any">look_set_prefix_any</a></li><li><a href="#method.look_set_suffix">look_set_suffix</a></li><li><a href="#method.look_set_suffix_any">look_set_suffix_any</a></li><li><a href="#method.maximum_len">maximum_len</a></li><li><a href="#method.memory_usage">memory_usage</a></li><li><a href="#method.minimum_len">minimum_len</a></li><li><a href="#method.static_explicit_captures_len">static_explicit_captures_len</a></li><li><a href="#method.union">union</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Clone-for-Properties">Clone</a></li><li><a href="#impl-Debug-for-Properties">Debug</a></li><li><a href="#impl-Eq-for-Properties">Eq</a></li><li><a href="#impl-PartialEq%3CProperties%3E-for-Properties">PartialEq&lt;Properties&gt;</a></li><li><a href="#impl-StructuralEq-for-Properties">StructuralEq</a></li><li><a href="#impl-StructuralPartialEq-for-Properties">StructuralPartialEq</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-Properties">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Properties">Send</a></li><li><a href="#impl-Sync-for-Properties">Sync</a></li><li><a href="#impl-Unpin-for-Properties">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Properties">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-Properties">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-Properties">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-Properties">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-Properties">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-Properties">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-Properties">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-Properties">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-Properties">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In regex_syntax::hir</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../index.html">regex_syntax</a>::<wbr><a href="index.html">hir</a>::<wbr><a class="struct" href="#">Properties</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/regex_syntax/hir/mod.rs.html#1952">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Properties(/* private fields */);</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A type that collects various properties of an HIR value.</p>
<p>Properties are always scalar values and represent meta data that is
computed inductively on an HIR value. Properties are defined for all
HIR values.</p>
<p>All methods on a <code>Properties</code> value take constant time and are meant to
be cheap to call.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Properties" class="impl"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#1977-2381">source</a><a href="#impl-Properties" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.minimum_len" class="method"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#1988-1990">source</a><h4 class="code-header">pub fn <a href="#method.minimum_len" class="fn">minimum_len</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the length (in bytes) of the smallest string matched by this
HIR.</p>
<p>A return value of <code>0</code> is possible and occurs when the HIR can match an
empty string.</p>
<p><code>None</code> is returned when there is no minimum length. This occurs in
precisely the cases where the HIR matches nothing. i.e., The language
the regex matches is empty. An example of such a regex is <code>\P{any}</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.maximum_len" class="method"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#2003-2005">source</a><h4 class="code-header">pub fn <a href="#method.maximum_len" class="fn">maximum_len</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the length (in bytes) of the longest string matched by this
HIR.</p>
<p>A return value of <code>0</code> is possible and occurs when nothing longer than
the empty string is in the language described by this HIR.</p>
<p><code>None</code> is returned when there is no longest matching string. This
occurs when the HIR matches nothing or when there is no upper bound on
the length of matching strings. Example of such regexes are <code>\P{any}</code>
(matches nothing) and <code>a+</code> (has no upper bound).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.look_set" class="method"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#2010-2012">source</a><h4 class="code-header">pub fn <a href="#method.look_set" class="fn">look_set</a>(&amp;self) -&gt; <a class="struct" href="struct.LookSet.html" title="struct regex_syntax::hir::LookSet">LookSet</a></h4></section></summary><div class="docblock"><p>Returns a set of all look-around assertions that appear at least once
in this HIR value.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.look_set_prefix" class="method"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#2021-2023">source</a><h4 class="code-header">pub fn <a href="#method.look_set_prefix" class="fn">look_set_prefix</a>(&amp;self) -&gt; <a class="struct" href="struct.LookSet.html" title="struct regex_syntax::hir::LookSet">LookSet</a></h4></section></summary><div class="docblock"><p>Returns a set of all look-around assertions that appear as a prefix for
this HIR value. That is, the set returned corresponds to the set of
assertions that must be passed before matching any bytes in a haystack.</p>
<p>For example, <code>hir.look_set_prefix().contains(Look::Start)</code> returns true
if and only if the HIR is fully anchored at the start.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.look_set_prefix_any" class="method"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#2034-2036">source</a><h4 class="code-header">pub fn <a href="#method.look_set_prefix_any" class="fn">look_set_prefix_any</a>(&amp;self) -&gt; <a class="struct" href="struct.LookSet.html" title="struct regex_syntax::hir::LookSet">LookSet</a></h4></section></summary><div class="docblock"><p>Returns a set of all look-around assertions that appear as a <em>possible</em>
prefix for this HIR value. That is, the set returned corresponds to the
set of assertions that <em>may</em> be passed before matching any bytes in a
haystack.</p>
<p>For example, <code>hir.look_set_prefix_any().contains(Look::Start)</code> returns
true if and only if it’s possible for the regex to match through a
anchored assertion before consuming any input.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.look_set_suffix" class="method"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#2046-2048">source</a><h4 class="code-header">pub fn <a href="#method.look_set_suffix" class="fn">look_set_suffix</a>(&amp;self) -&gt; <a class="struct" href="struct.LookSet.html" title="struct regex_syntax::hir::LookSet">LookSet</a></h4></section></summary><div class="docblock"><p>Returns a set of all look-around assertions that appear as a suffix for
this HIR value. That is, the set returned corresponds to the set of
assertions that must be passed in order to be considered a match after
all other consuming HIR expressions.</p>
<p>For example, <code>hir.look_set_suffix().contains(Look::End)</code> returns true
if and only if the HIR is fully anchored at the end.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.look_set_suffix_any" class="method"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#2059-2061">source</a><h4 class="code-header">pub fn <a href="#method.look_set_suffix_any" class="fn">look_set_suffix_any</a>(&amp;self) -&gt; <a class="struct" href="struct.LookSet.html" title="struct regex_syntax::hir::LookSet">LookSet</a></h4></section></summary><div class="docblock"><p>Returns a set of all look-around assertions that appear as a <em>possible</em>
suffix for this HIR value. That is, the set returned corresponds to the
set of assertions that <em>may</em> be passed before matching any bytes in a
haystack.</p>
<p>For example, <code>hir.look_set_suffix_any().contains(Look::End)</code> returns
true if and only if it’s possible for the regex to match through a
anchored assertion at the end of a match without consuming any input.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_utf8" class="method"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#2128-2130">source</a><h4 class="code-header">pub fn <a href="#method.is_utf8" class="fn">is_utf8</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return true if and only if the corresponding HIR will always match
valid UTF-8.</p>
<p>When this returns false, then it is possible for this HIR expression to
match invalid UTF-8, including by matching between the code units of
a single UTF-8 encoded codepoint.</p>
<p>Note that this returns true even when the corresponding HIR can match
the empty string. Since an empty string can technically appear between
UTF-8 code units, it is possible for a match to be reported that splits
a codepoint which could in turn be considered matching invalid UTF-8.
However, it is generally assumed that such empty matches are handled
specially by the search routine if it is absolutely required that
matches not split a codepoint.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<p>This code example shows the UTF-8 property of a variety of patterns.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_syntax::{ParserBuilder, parse};

<span class="comment">// Examples of &#39;is_utf8() == true&#39;.
</span><span class="macro">assert!</span>(parse(<span class="string">r&quot;a&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(parse(<span class="string">r&quot;[^a]&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(parse(<span class="string">r&quot;.&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(parse(<span class="string">r&quot;\W&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(parse(<span class="string">r&quot;\b&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(parse(<span class="string">r&quot;\B&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(parse(<span class="string">r&quot;(?-u)\b&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(parse(<span class="string">r&quot;(?-u)\B&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="comment">// Unicode mode is enabled by default, and in
// that mode, all \x hex escapes are treated as
// codepoints. So this actually matches the UTF-8
// encoding of U+00FF.
</span><span class="macro">assert!</span>(parse(<span class="string">r&quot;\xFF&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());

<span class="comment">// Now we show examples of &#39;is_utf8() == false&#39;.
// The only way to do this is to force the parser
// to permit invalid UTF-8, otherwise all of these
// would fail to parse!
</span><span class="kw">let </span>parse = |pattern| {
    ParserBuilder::new().utf8(<span class="bool-val">false</span>).build().parse(pattern)
};
<span class="macro">assert!</span>(!parse(<span class="string">r&quot;(?-u)[^a]&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(!parse(<span class="string">r&quot;(?-u).&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="macro">assert!</span>(!parse(<span class="string">r&quot;(?-u)\W&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="comment">// Conversely to the equivalent example above,
// when Unicode mode is disabled, \x hex escapes
// are treated as their raw byte values.
</span><span class="macro">assert!</span>(!parse(<span class="string">r&quot;(?-u)\xFF&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="comment">// Note that just because we disabled UTF-8 in the
// parser doesn&#39;t mean we still can&#39;t use Unicode.
// It is enabled by default, so \xFF is still
// equivalent to matching the UTF-8 encoding of
// U+00FF by default.
</span><span class="macro">assert!</span>(parse(<span class="string">r&quot;\xFF&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
<span class="comment">// Even though we use raw bytes that individually
// are not valid UTF-8, when combined together, the
// overall expression *does* match valid UTF-8!
</span><span class="macro">assert!</span>(parse(<span class="string">r&quot;(?-u)\xE2\x98\x83&quot;</span>)<span class="question-mark">?</span>.properties().is_utf8());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.explicit_captures_len" class="method"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#2152-2154">source</a><h4 class="code-header">pub fn <a href="#method.explicit_captures_len" class="fn">explicit_captures_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total number of explicit capturing groups in the
corresponding HIR.</p>
<p>Note that this does not include the implicit capturing group
corresponding to the entire match that is typically included by regex
engines.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<p>This method will return <code>0</code> for <code>a</code> and <code>1</code> for <code>(a)</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_syntax::parse;

<span class="macro">assert_eq!</span>(<span class="number">0</span>, parse(<span class="string">&quot;a&quot;</span>)<span class="question-mark">?</span>.properties().explicit_captures_len());
<span class="macro">assert_eq!</span>(<span class="number">1</span>, parse(<span class="string">&quot;(a)&quot;</span>)<span class="question-mark">?</span>.properties().explicit_captures_len());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.static_explicit_captures_len" class="method"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#2192-2194">source</a><h4 class="code-header">pub fn <a href="#method.static_explicit_captures_len" class="fn">static_explicit_captures_len</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the total number of explicit capturing groups that appear in
every possible match.</p>
<p>If the number of capture groups can vary depending on the match, then
this returns <code>None</code>. That is, a value is only returned when the number
of matching groups is invariant or “static.”</p>
<p>Note that this does not include the implicit capturing group
corresponding to the entire match.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<p>This shows a few cases where a static number of capture groups is
available and a few cases where it is not.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_syntax::parse;

<span class="kw">let </span>len = |pattern| {
    parse(pattern).map(|h| {
        h.properties().static_explicit_captures_len()
    })
};

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">0</span>), len(<span class="string">&quot;a&quot;</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), len(<span class="string">&quot;(a)&quot;</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), len(<span class="string">&quot;(a)|(b)&quot;</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">2</span>), len(<span class="string">&quot;(a)(b)|(c)(d)&quot;</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, len(<span class="string">&quot;(a)|b&quot;</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, len(<span class="string">&quot;a|(b)&quot;</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, len(<span class="string">&quot;(b)*&quot;</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), len(<span class="string">&quot;(b)+&quot;</span>)<span class="question-mark">?</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_literal" class="method"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#2204-2206">source</a><h4 class="code-header">pub fn <a href="#method.is_literal" class="fn">is_literal</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return true if and only if this HIR is a simple literal. This is
only true when this HIR expression is either itself a <code>Literal</code> or a
concatenation of only <code>Literal</code>s.</p>
<p>For example, <code>f</code> and <code>foo</code> are literals, but <code>f+</code>, <code>(foo)</code>, <code>foo()</code> and
the empty string are not (even though they contain sub-expressions that
are literals).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_alternation_literal" class="method"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#2217-2219">source</a><h4 class="code-header">pub fn <a href="#method.is_alternation_literal" class="fn">is_alternation_literal</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return true if and only if this HIR is either a simple literal or an
alternation of simple literals. This is only
true when this HIR expression is either itself a <code>Literal</code> or a
concatenation of only <code>Literal</code>s or an alternation of only <code>Literal</code>s.</p>
<p>For example, <code>f</code>, <code>foo</code>, <code>a|b|c</code>, and <code>foo|bar|baz</code> are alternation
literals, but <code>f+</code>, <code>(foo)</code>, <code>foo()</code>, and the empty pattern are not
(even though that contain sub-expressions that are literals).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.memory_usage" class="method"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#2224-2226">source</a><h4 class="code-header">pub fn <a href="#method.memory_usage" class="fn">memory_usage</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the total amount of heap memory usage, in bytes, used by this
<code>Properties</code> value.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.union" class="method"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#2298-2380">source</a><h4 class="code-header">pub fn <a href="#method.union" class="fn">union</a>&lt;I, P&gt;(props: I) -&gt; <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a><span class="where fmt-newline">where
    I: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = P&gt;,
    P: <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a new set of properties that corresponds to the union of the
iterator of properties given.</p>
<p>This is useful when one has multiple <code>Hir</code> expressions and wants
to combine them into a single alternation without constructing the
corresponding <code>Hir</code>. This routine provides a way of combining the
properties of each <code>Hir</code> expression into one set of properties
representing the union of those expressions.</p>
<h5 id="example-union-with-hirs-that-never-match"><a href="#example-union-with-hirs-that-never-match">Example: union with HIRs that never match</a></h5>
<p>This example shows that unioning properties together with one that
represents a regex that never matches will “poison” certain attributes,
like the minimum and maximum lengths.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_syntax::{hir::Properties, parse};

<span class="kw">let </span>hir1 = parse(<span class="string">&quot;ab?c?&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), hir1.properties().minimum_len());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">3</span>), hir1.properties().maximum_len());

<span class="kw">let </span>hir2 = parse(<span class="string">r&quot;[a&amp;&amp;b]&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, hir2.properties().minimum_len());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, hir2.properties().maximum_len());

<span class="kw">let </span>hir3 = parse(<span class="string">r&quot;wxy?z?&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">2</span>), hir3.properties().minimum_len());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>), hir3.properties().maximum_len());

<span class="kw">let </span>unioned = Properties::union([
	hir1.properties(),
	hir2.properties(),
	hir3.properties(),
]);
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, unioned.minimum_len());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, unioned.maximum_len());
</code></pre></div>
<p>The maximum length can also be “poisoned” by a pattern that has no
upper bound on the length of a match. The minimum length remains
unaffected:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_syntax::{hir::Properties, parse};

<span class="kw">let </span>hir1 = parse(<span class="string">&quot;ab?c?&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), hir1.properties().minimum_len());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">3</span>), hir1.properties().maximum_len());

<span class="kw">let </span>hir2 = parse(<span class="string">r&quot;a+&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), hir2.properties().minimum_len());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, hir2.properties().maximum_len());

<span class="kw">let </span>hir3 = parse(<span class="string">r&quot;wxy?z?&quot;</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">2</span>), hir3.properties().minimum_len());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>), hir3.properties().maximum_len());

<span class="kw">let </span>unioned = Properties::union([
	hir1.properties(),
	hir2.properties(),
	hir3.properties(),
]);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), unioned.minimum_len());
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, unioned.maximum_len());
</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Properties" class="impl"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#1951">source</a><a href="#impl-Clone-for-Properties" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#1951">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Properties" class="impl"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#1951">source</a><a href="#impl-Debug-for-Properties" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#1951">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CProperties%3E-for-Properties" class="impl"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#1951">source</a><a href="#impl-PartialEq%3CProperties%3E-for-Properties" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a>&gt; for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#1951">source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#231">source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><section id="impl-Eq-for-Properties" class="impl"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#1951">source</a><a href="#impl-Eq-for-Properties" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section><section id="impl-StructuralEq-for-Properties" class="impl"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#1951">source</a><a href="#impl-StructuralEq-for-Properties" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.StructuralEq.html" title="trait core::marker::StructuralEq">StructuralEq</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section><section id="impl-StructuralPartialEq-for-Properties" class="impl"><a class="src rightside" href="../../src/regex_syntax/hir/mod.rs.html#1951">source</a><a href="#impl-StructuralPartialEq-for-Properties" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Properties" class="impl"><a href="#impl-RefUnwindSafe-for-Properties" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section><section id="impl-Send-for-Properties" class="impl"><a href="#impl-Send-for-Properties" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section><section id="impl-Sync-for-Properties" class="impl"><a href="#impl-Sync-for-Properties" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section><section id="impl-Unpin-for-Properties" class="impl"><a href="#impl-Unpin-for-Properties" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section><section id="impl-UnwindSafe-for-Properties" class="impl"><a href="#impl-UnwindSafe-for-Properties" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Properties.html" title="struct regex_syntax::hir::Properties">Properties</a></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-Properties" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#135">source</a><a href="#impl-Any-for-Properties" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#136">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-Properties" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-Properties" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-Properties" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-Properties" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-Properties" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#722">source</a><a href="#impl-From%3CT%3E-for-Properties" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#725">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-Properties" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#706">source</a><a href="#impl-Into%3CU%3E-for-Properties" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#715">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-Properties" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#82">source</a><a href="#impl-ToOwned-for-Properties" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#87">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#91">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-Properties" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#762">source</a><a href="#impl-TryFrom%3CU%3E-for-Properties" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#769">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-Properties" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#747">source</a><a href="#impl-TryInto%3CU%3E-for-Properties" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#754">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>