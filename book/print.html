<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust GPU Dev Guide</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Contributing to Rust-GPU</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="building-rust-gpu.html"><strong aria-hidden="true">2.1.</strong> Building</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">2.2.</strong> Testing</a></li><li class="chapter-item expanded "><a href="compiler-env-vars.html"><strong aria-hidden="true">2.3.</strong> Environment variables Rust-GPU reads</a></li><li class="chapter-item expanded "><a href="spirv-minimization.html"><strong aria-hidden="true">2.4.</strong> Minimizing bugs in SPIR-V</a></li><li class="chapter-item expanded "><a href="publishing-rust-gpu.html"><strong aria-hidden="true">2.5.</strong> Publishing rust-gpu on crates.io</a></li></ol></li><li class="chapter-item expanded "><a href="platform-support.html"><strong aria-hidden="true">3.</strong> Platform Support</a></li><li class="chapter-item expanded "><a href="writing-shader-crates.html"><strong aria-hidden="true">4.</strong> Writing Shader Crates</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Features</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="attributes.html"><strong aria-hidden="true">5.1.</strong> Attribute syntax</a></li><li class="chapter-item expanded "><a href="inline-asm.html"><strong aria-hidden="true">5.2.</strong> Inline Assembly</a></li><li class="chapter-item expanded "><a href="image.html"><strong aria-hidden="true">5.3.</strong> Image type syntax</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> RFCs</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="rfcs/001-resource-binding-syntax.html"><strong aria-hidden="true">6.1.</strong> 001. Resource Binding Syntax</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust GPU Dev Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the Rust-GPU dev guide! This documentation is meant for documenting
how to use and develop on Rust-GPU.</p>
<p>If you're looking to get started with writing your own shaders in Rust, 
check out the <a href="./writing-shader-crates.html"><em>&quot;Writing Shader Crates&quot;</em></a> section for
more information on how to get started.</p>
<p>Alternatively if you're looking to contribute to the <code>rust-gpu</code> project, have
a look at <a href="./building-rust-gpu.html"><em>&quot;Building Rust-GPU&quot;</em></a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-rust-gpu"><a class="header" href="#building-rust-gpu">Building Rust-GPU</a></h1>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<ol>
<li>
<p>Clone the repository.</p>
<pre><code class="language-shell">git clone --recurse-submodules https://github.com/EmbarkStudios/rust-gpu
</code></pre>
</li>
<li>
<p><strong>optional</strong> Install <a href="https://github.com/KhronosGroup/SPIRV-Tools#downloads">SPIRV-Tools</a> and add it to your <code>PATH</code>. You can skip this step if you just want to run examples with the defaults. See <a href="building-rust-gpu.html#using-installed-spirv-tools">Using installed SPIRV-Tools</a> if you decide to go with this option.</p>
</li>
<li>
<p>Next, look at the <a href="https://github.com/EmbarkStudios/rust-gpu/tree/main/examples">examples</a> folder. There are two kinds of targets here: [runners] and [shaders]. The projects inside <code>shaders</code> are &quot;GPU crates&quot;, i.e. ones that will be compiled to one or more SPIR-V modules. The <code>runner</code> projects are normal, CPU crates that use some graphics backend (currently, we have a <a href="https://github.com/EmbarkStudios/rust-gpu/tree/main/examples/runners/wgpu"><code>wgpu</code> runner</a>, a <a href="https://github.com/EmbarkStudios/rust-gpu/tree/main/examples/runners/ash">Vulkan runner</a> through <code>ash</code>, and a barebones pure software <a href="https://github.com/EmbarkStudios/rust-gpu/tree/main/examples/runners/cpu">CPU runner</a>) to actually run one of the &quot;GPU crate&quot; shaders.</p>
<p>Run the example:</p>
<pre><code class="language-shell">cargo run --bin example-runner-wgpu
</code></pre>
<p>This will build <code>rustc_codegen_spirv</code>, the compiler, then use that compiler to build <a href="examples/shaders/sky-shader"><code>sky-shader</code></a> into a SPIR-V module, then finally, build a <code>wgpu</code> sample app (modified from <a href="https://github.com/gfx-rs/wgpu-rs/tree/master/examples/hello-triangle"><code>wgpu</code>'s examples</a>) using the built SPIR-V module to display the shader in a window.</p>
</li>
</ol>
<h2 id="prerequisite-linux-packages-recommended-to-install-before-building-rust-gpu"><a class="header" href="#prerequisite-linux-packages-recommended-to-install-before-building-rust-gpu">Prerequisite linux packages recommended to install before building Rust-GPU</a></h2>
<p>You may need the development version (i.e. headers/etc. included) of some packages in some distributions to be able to
build the examples - specifically, x11 and libxkbcommon, as well as gcc/clang with c++ support. These packages may be
called (fedora) <code>libX11-devel</code>, <code>libxkbcommon-x11-devel</code>, and <code>gcc-c++</code>, or (ubuntu) <code>libxkbcommon-x11-dev</code>,
<code>libx11-dev</code>, and <code>gcc</code>.</p>
<h2 id="using-installed-spirv-tools"><a class="header" href="#using-installed-spirv-tools">Using installed SPIRV-Tools</a></h2>
<p>By default, all of the crates and examples in this repo will compile the <a href="https://crates.io/crates/spirv-tools-sys"><code>spirv-tools-sys</code></a> crate, including a lot of C++ code from <a href="https://github.com/EmbarkStudios/SPIRV-Tools">SPIRV-Tools</a>. If you don't want to build the C++ code because you already have <a href="https://github.com/KhronosGroup/SPIRV-Tools#downloads">SPIRV-Tools</a> installed, or just don't want to spend more time compiling, you can build/run the crate with the <code>use-installed-tools</code> feature.</p>
<pre><code class="language-shell">cargo run \
    --manifest-path examples/example-runner/Cargo.toml \
    --features use-installed-tools \
    --no-default-features
</code></pre>
<p>You should see <code>warning: use-installed-tools feature on, skipping compilation of C++ code</code> during the compilation, but otherwise the build will function just the same as if you compiled the C++ code, with the exception that it will fail if you don't have SPIRV-Tools installed correctly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-rust-gpu"><a class="header" href="#testing-rust-gpu">Testing Rust-GPU</a></h1>
<p>Rust-GPU has a couple of different kinds of tests, most can be ran through
<code>cargo test</code>, however Rust-GPU also has end-to-end tests for compiling Rust and
validating its SPIR-V output, which can ran by running <code>cargo compiletest</code>.</p>
<pre><code class="language-bash">cargo test &amp;&amp; cargo compiletest
</code></pre>
<h2 id="adding-tests"><a class="header" href="#adding-tests">Adding Tests</a></h2>
<p>Rust-GPU's end-to-end test's use an external version of the <a href="https://github.com/laumann/compiletest-rs"><code>compiletest</code></a> tool
as a testing framework. Be sure to check out the <a href="https://github.com/laumann/compiletest-rs">repository</a> and
the <a href="https://rustc-dev-guide.rust-lang.org/tests/intro.html">rustc Dev-Guide</a> for more information about how it works,
how to configure it, and add new tests.</p>
<h3 id="blessing-tests"><a class="header" href="#blessing-tests">Blessing Tests</a></h3>
<p>You will occassionally need to &quot;bless&quot; the output from UI tests to update the
normalised output, you can do this by passing a <code>--bless</code> flag to
<code>cargo compiletest</code>.</p>
<pre><code class="language-bash">cargo compiletest --bless
</code></pre>
<h3 id="filtering-tests"><a class="header" href="#filtering-tests">Filtering Tests</a></h3>
<p>When working on tests, you may need to run <code>cargo compiletest</code> a few times,
while changing only a small number of tests. You can avoid having to run all
the other (unrelated) tests, by passing substrings of their paths, to
<code>cargo compiletest</code>, for example:</p>
<pre><code class="language-bash">cargo compiletest arch/u image
</code></pre>
<p>The above command will only test <code>ui/arch/u_*.rs</code> and <code>ui/image/*.rs</code>, and skip
everything else. You can also add <code>--bless</code> to update expected outputs, as well.</p>
<h3 id="testing-different-environments"><a class="header" href="#testing-different-environments">Testing Different Environments</a></h3>
<p>You can test against multiple different SPIR-V environments with the
<code>--target-env</code> flag. By default it is set to <code>unknown</code>.</p>
<pre><code class="language-bash">cargo compiletest --target-env=vulkan1.1
# You can also provide multiple values to test multiple environments
cargo compiletest --target-env=vulkan1.1,spv.1.3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug-environment-variables-that-the-rust-gpu-compiler-reads"><a class="header" href="#debug-environment-variables-that-the-rust-gpu-compiler-reads">Debug environment variables that the Rust-GPU compiler reads</a></h1>
<p>Please keep in mind that all of these variables are for internal development, and may break output
unexpectedly and generally muck things up. Please only use these if you know what you're doing.</p>
<p>Help is also appreciated keeping this document up to date, environment variables may be
added/removed on an ad-hoc basis without much thought, as they're internal development tools, not a
public API - this documentation is only here because these variables may be helpful diagnosing
problems for others.</p>
<p>It's recommended that environment variables that take paths to files or directories are set to full
paths, as the working directory of the compiler might be something wonky and unexpected, and it's
easier to set the full path.</p>
<h2 id="dump_mir"><a class="header" href="#dump_mir">DUMP_MIR</a></h2>
<p>Takes: path to file</p>
<p>Dumps the MIR of every function rust-gpu encounters to a file. Yes, rustc does have options to do
this by default, but I always forget the syntax, and plumbing through the option to spirv-builder
is annoying, so this is handy to just hack an output.</p>
<h2 id="dump_module_on_panic"><a class="header" href="#dump_module_on_panic">DUMP_MODULE_ON_PANIC</a></h2>
<p>Takes: path to file</p>
<p>If codegen panics, then write the (partially) emitted module to a file. Note that this only exists
for codegen, if the linker panics, this option does nothing, sadly.</p>
<h2 id="dump_pre_link"><a class="header" href="#dump_pre_link">DUMP_PRE_LINK</a></h2>
<p>Takes: path to directory</p>
<p>Dumps all input modules to the linker, before the linker touches them at all.</p>
<h2 id="dump_post_merge"><a class="header" href="#dump_post_merge">DUMP_POST_MERGE</a></h2>
<p>Takes: path to file</p>
<p>Dumps the merged module immediately after merging, but before the linker has done anything else
(including, well, linking the methods - LinkageAttributes will still exist, etc.). This is very
similar to DUMP_PRE_LINK, except it outputs only a single file, which might make grepping through
for stuff easier.</p>
<h2 id="dump_post_split"><a class="header" href="#dump_post_split">DUMP_POST_SPLIT</a></h2>
<p>Takes: path to directory</p>
<p>Dumps the modules immediately after multimodule splitting, but before final cleanup passes (e.g.
DCE to remove the other entry points).</p>
<h2 id="dump_post_link"><a class="header" href="#dump_post_link">DUMP_POST_LINK</a></h2>
<p>Takes: path to directory</p>
<p>Dumps all output modules from the linker. This may be multiple files due to the multimodule/module
splitting option, hence it takes a directory instead of a file path. This is the final output
binary before spirv-opt is executed, so it may be useful to output this to check if an issue is in
rust-gpu, or in spirv-opt.</p>
<h2 id="specializer_debug"><a class="header" href="#specializer_debug">SPECIALIZER_DEBUG</a></h2>
<p>Takes: presence or absence (e.g. set to <code>1</code>)</p>
<p>Prints to rustc stdout some debug information about the specializer.</p>
<h2 id="specializer_dump_instances"><a class="header" href="#specializer_dump_instances">SPECIALIZER_DUMP_INSTANCES</a></h2>
<p>Takes: path to file</p>
<p>Prints to file some... stuff, idk, ask eddyb (useful for debugging specializer)</p>
<h2 id="print_zombie"><a class="header" href="#print_zombie">PRINT_ZOMBIE</a></h2>
<p>Takes: presence or absence (e.g. set to <code>1</code>)</p>
<p>Prints to rustc stdout which functions were removed due to being zombies, and why.</p>
<h2 id="print_all_zombie"><a class="header" href="#print_all_zombie">PRINT_ALL_ZOMBIE</a></h2>
<p>Takes: presence or absence (e.g. set to <code>1</code>)</p>
<p>Prints to rustc stdout <em>everything</em> that was removed due to being zombies, why, and if it was an
original zombie or if it was infected. (prints a lot!)</p>
<h2 id="no_spirv_val"><a class="header" href="#no_spirv_val">NO_SPIRV_VAL</a></h2>
<p>Takes: presence or absence (e.g. set to <code>1</code>)</p>
<p>Disables running spirv-val on the final output. Spooky scary option, can cause invalid modules!</p>
<h2 id="no_spirv_opt"><a class="header" href="#no_spirv_opt">NO_SPIRV_OPT</a></h2>
<p>Takes: presence or absence (e.g. set to <code>1</code>)</p>
<p>Forcibly disables running spirv-opt on the final output, even if optimizations are enabled.</p>
<h2 id="no_dce"><a class="header" href="#no_dce">NO_DCE</a></h2>
<p>Takes: presence or absence (e.g. set to <code>1</code>)</p>
<p>Disables running dead code elimination. Can and probably will generate invalid modules or crash the
linker, hasn't been tested for a while.</p>
<h2 id="no_compact_ids"><a class="header" href="#no_compact_ids">NO_COMPACT_IDS</a></h2>
<p>Takes: presence or absence (e.g. set to <code>1</code>)</p>
<p>Disables compaction of SPIR-V IDs at the end of linking. Causes absolutely ginormous IDs to be
emitted. Useful if you're println debugging IDs in the linker (although spirv-opt will compact them
anyway, be careful).</p>
<h2 id="no_structurize"><a class="header" href="#no_structurize">NO_STRUCTURIZE</a></h2>
<p>Takes: presence or absence (e.g. set to <code>1</code>)</p>
<p>Disables structurization. Probably results in invalid modules.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimizing-bugs-in-spir-v"><a class="header" href="#minimizing-bugs-in-spir-v">Minimizing bugs in SPIR-V</a></h1>
<p>When debugging problems with SPIR-V generated by rust-gpu, you occasionally need
to reduce the SPIR-V in order to make it easily shareable with others. We've
created a short guide on how to do that.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>In order to build and validate SPIR-V you're going to install <a href="https://github.com/KhronosGroup/SPIRV-Tools#downloads">SPIR-V
tools</a>.</p>
<h2 id="spir-v-template"><a class="header" href="#spir-v-template">SPIR-V Template</a></h2>
<p>SPIR-V has some amount of required boilerplate in order to be considered valid,
we've created a small template to help to get started. This file creates a
single empty vertex entry-point with a single floating-point constant.</p>
<pre><code class="language-spirv">; bug.spvasm
OpCapability Shader
OpCapability VulkanMemoryModel
OpMemoryModel Logical Vulkan

; == Entry-points ==
OpEntryPoint Vertex %vert_fn &quot;vert&quot;

; == Types ==
%void = OpTypeVoid
%f32 = OpTypeFloat 32

; Function Types
%void_fn = OpTypeFunction %void

; == Constants ==
%f32_1 = OpConstant %f32 1

; == Functions ==
%vert_fn = OpFunction %void None %void_fn
  %block = OpLabel
    OpReturn
OpFunctionEnd
</code></pre>
<h2 id="steps"><a class="header" href="#steps">Steps</a></h2>
<ol>
<li>
<p>Assemble your spirv with <code>spirv-as ./bug.spvasm</code>, this will produce a
<code>out.spv</code> file containing the assembled code.</p>
</li>
<li>
<p>The assembled code also needs to be validated with <code>spirv-val out.spv</code></p>
</li>
<li>
<p>Once the code has been validated as having no issues, you can use
<code>spirv-cross</code> to compile the code to various outputs.</p>
<ul>
<li><strong>GLSL</strong> <code>spirv-cross out.spv</code></li>
<li><strong>HLSL</strong> <code>spirv-cross --hlsl out.spv</code></li>
<li><strong>MSL</strong> <code>spirv-cross --msl out.spv</code></li>
<li><strong>Vulkan GLSL</strong> <code>spirv-cross -V out.spv</code></li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-rust-gpu-on-cratesio"><a class="header" href="#publishing-rust-gpu-on-cratesio">Publishing rust-gpu on crates.io</a></h1>
<p>This is a task list for the maintainers of rust-gpu to remember to do when publishing a new version
of rust-gpu (probably not useful for contributors without access to embark's crates.io account :P)</p>
<ol>
<li>Bump all the versions in rust-gpu to the next one. I've found this command to be useful:
<code>rg --files-with-matches alpha | xargs sed -i 's/0.4.0-alpha.10/0.4.0-alpha.12/g'</code> (replacing with
whatever versions are relevant)</li>
<li>Create a PR with that change. Wait for CI and a review, and merge it.</li>
<li>Pull the merged <code>main</code> branch.</li>
<li>Tag <code>main</code> with the version: <code>git tag v0.4.0-alpha.12</code></li>
<li>Push the tag: <code>git push origin v0.4.0-alpha.12</code></li>
<li>Publish the crates: <code>cd [crate] &amp;&amp; cargo publish</code> (make sure <code>.cargo/credentials</code> is set to
embark's token) - crates to be published, in order:
<ol>
<li>crates/spirv-std/shared</li>
<li>crates/spirv-std/macros</li>
<li>crates/spirv-std</li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h1>
<p>The <code>rust-gpu</code> project currently supports a limited number of platforms and graphics APIs. Right now we're not distributing build artifacts and we're primarily focused on the development of the project, so this is based on the current <code>main</code> branch. There are a lot of different configurations and hardware out there to support, this document is intended to document what is currently supported, what we intend to support, and what isn't supported. Over time as the project stabilises and our CI improves, more platforms and APIs will be supported and tested. Currently support for each topic is divided into the following three categories.</p>
<ul>
<li><strong>Primary —</strong> Built and tested on CI.</li>
<li><strong>Secondary —</strong> Built but <em>not fully tested</em> on CI.</li>
<li><strong>Tertiary —</strong> Present in the codebase but not built or tested.</li>
</ul>
<h2 id="operating-system"><a class="header" href="#operating-system">Operating System</a></h2>
<table><thead><tr><th>Operating System</th><th>Version</th><th>Support</th><th>Notes</th></tr></thead><tbody>
<tr><td>Windows</td><td>10+</td><td>Primary</td><td></td></tr>
<tr><td>Linux</td><td>Ubuntu 18.04+</td><td>Primary</td><td></td></tr>
<tr><td>macOS</td><td>Catalina (10.15)+</td><td>Secondary</td><td>Using <a href="https://github.com/KhronosGroup/MoltenVK">MoltenVK</a>, requires v1.1.2+</td></tr>
<tr><td>Android</td><td>Tested 10-11</td><td>Secondary</td><td></td></tr>
</tbody></table>
<h2 id="graphics-apis"><a class="header" href="#graphics-apis">Graphics APIs</a></h2>
<table><thead><tr><th>Name</th><th>Version</th><th>Support</th><th>Notes</th></tr></thead><tbody>
<tr><td>SPIR-V</td><td>1.3+</td><td>Primary</td><td></td></tr>
<tr><td>Vulkan</td><td>1.1+</td><td>Primary</td><td></td></tr>
<tr><td>WGPU</td><td>0.6</td><td>Primary</td><td>Uses a translation layer to Metal/DX12</td></tr>
<tr><td>OpenGL</td><td>???</td><td>Tertiary</td><td></td></tr>
</tbody></table>
<h3 id="spir-v-targets"><a class="header" href="#spir-v-targets">SPIR-V Targets</a></h3>
<ul>
<li><code>spirv-unknown-spv1.0</code></li>
<li><code>spirv-unknown-spv1.1</code></li>
<li><code>spirv-unknown-spv1.2</code></li>
<li><code>spirv-unknown-spv1.3</code></li>
<li><code>spirv-unknown-spv1.4</code></li>
<li><code>spirv-unknown-spv1.5</code></li>
</ul>
<h3 id="vulkan-targets"><a class="header" href="#vulkan-targets">Vulkan Targets</a></h3>
<ul>
<li><code>spirv-unknown-vulkan1.0</code></li>
<li><code>spirv-unknown-vulkan1.1</code></li>
<li><code>spirv-unknown-vulkan1.1spv1.4</code></li>
<li><code>spirv-unknown-vulkan1.2</code></li>
</ul>
<h3 id="webgpu-targets"><a class="header" href="#webgpu-targets">WebGPU Targets</a></h3>
<ul>
<li><code>spirv-unknown-webgpu0</code></li>
</ul>
<h3 id="opengl-targets"><a class="header" href="#opengl-targets">OpenGL Targets</a></h3>
<ul>
<li><code>spirv-unknown-opengl4.0</code></li>
<li><code>spirv-unknown-opengl4.1</code></li>
<li><code>spirv-unknown-opengl4.2</code></li>
<li><code>spirv-unknown-opengl4.3</code></li>
<li><code>spirv-unknown-opengl4.5</code></li>
</ul>
<h3 id="opencl-targets"><a class="header" href="#opencl-targets">OpenCL Targets</a></h3>
<ul>
<li><code>spirv-unknown-opencl1.2</code></li>
<li><code>spirv-unknown-opencl1.2embedded</code></li>
<li><code>spirv-unknown-opencl2.0</code></li>
<li><code>spirv-unknown-opencl2.0embedded</code></li>
<li><code>spirv-unknown-opencl2.1</code></li>
<li><code>spirv-unknown-opencl2.1embedded</code></li>
<li><code>spirv-unknown-opencl2.2</code></li>
<li><code>spirv-unknown-opencl2.2embedded</code></li>
</ul>
<h2 id="gpu"><a class="header" href="#gpu">GPU</a></h2>
<p>Currently we don't have specific generations of GPUs for support, as long they support Vulkan 1.1+ with the latest officially installed drivers it should be able build and run the examples. You can check your Vulkan version using the <a href="https://vulkan.lunarg.com/doc/view/latest/windows/vulkaninfo.html"><code>vulkaninfo</code></a> command from the <code>vulkan-sdk</code>.</p>
<h5 id="drivers"><a class="header" href="#drivers">Drivers</a></h5>
<ul>
<li><a href="https://www.amd.com/en/support/kb/faq/gpu-56"><strong>AMD</strong></a></li>
<li><strong>Intel:</strong> <a href="https://www.intel.com/content/www/us/en/support/articles/000005520/graphics.html">Linux</a>, <a href="https://www.intel.com/content/www/us/en/support/articles/000022440/graphics.html">macOS</a>, <a href="https://downloadcenter.intel.com/product/80939/Graphics">Windows</a></li>
<li><a href="https://www.nvidia.com/Download/index.aspx?lang=en-us"><strong>Nvidia</strong></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-shader-crates"><a class="header" href="#writing-shader-crates">Writing Shader Crates</a></h1>
<p>This is section is going to walk you through writing a shader in Rust and
setting up your shader crate.</p>
<p>Be aware that this project is in a very early phase, please <a href="https://github.com/EmbarkStudios/rust-gpu/issues">file an
issue</a> if there's something
not working or unclear.</p>
<h2 id="online"><a class="header" href="#online">Online</a></h2>
<p>You can now test out and try building shaders with rust-gpu from the browser!</p>
<ul>
<li><a href="https://shadered.org/template">SHADERed</a> A shader IDE which has a lite version, which allows you to build
and run shaders on the web.</li>
<li><a href="http://shader-playground.timjones.io/9d744d5893beb6a8f129fda50ad4aeeb">Shader Playground</a> A playground for building and checking the output of
shader code similar to godbolt or play.rust-lang.org.</li>
</ul>
<h2 id="local-setup"><a class="header" href="#local-setup">Local Setup</a></h2>
<p>There are two main ways to setup your shader project locally.</p>
<ol>
<li>Using the <code>spirv-builder</code> crate.
The <code>spirv-builder</code> is a crate designed to automate the process of building
and linking the <code>rust-gpu</code> to be able to compile SPIR-V shaders into your
main Rust crate.</li>
<li>Using <code>.cargo/config</code>.
Alternatively if you're willing to do the setup yourself you can manually set
flags in your cargo configuration to enable you to run <code>cargo build</code> in your
shader crate.</li>
</ol>
<h3 id="using-spirv-builder"><a class="header" href="#using-spirv-builder">Using <code>spirv-builder</code></a></h3>
<p>If you're writing a bigger application and you want to integrate SPIR-V shader
crates to display, it's recommended to use <code>spirv-builder</code> in a build script.</p>
<ol>
<li>Copy the <a href="https://github.com/EmbarkStudios/rust-gpu/blob/main/rust-toolchain"><code>rust-toolchain</code></a> file to your project. (You must use the same
version of Rust as <code>rust-gpu</code>.)</li>
<li>Reference <code>spirv-builder</code> in your Cargo.toml:
<pre><code class="language-toml">[build-dependencies]
spirv-builder = { git = &quot;https://github.com/EmbarkStudios/rust-gpu&quot; }
</code></pre>
(we currently do not publish spirv-builder on crates.io)</li>
<li>Create a <code>build.rs</code> in your project root.</li>
</ol>
<h4 id="buildrs"><a class="header" href="#buildrs"><code>build.rs</code></a></h4>
<p>Paste the following into the <code>main</code> for your build script.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>SpirvBuilder::new(path_to_shader, target)
        .print_metadata(MetadataPrintout::Full)
        .build()?;
<span class="boring">}
</span></code></pre></pre>
<p>The values available for the <code>target</code> parameter are available
<a href="./platform-support.html">here</a>.  For example, if building for vulkan 1.1, use
<code>&quot;spirv-unknown-vulkan1.1&quot;</code>.</p>
<p>The <code>SpirvBuilder</code> struct has numerous configuration options available, see
rustdoc for documentation.</p>
<h4 id="mainrs"><a class="header" href="#mainrs"><code>main.rs</code></a></h4>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SHADER: &amp;[u8] = include_bytes!(env!(&quot;&lt;shader_name&gt;.spv&quot;));
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong> If your shader name contains hyphens, the name of environment variable will be the name with hyphens changed to underscores.</p>
</blockquote>
<p>Keep in mind that by default, build-dependencies are built in debug mode. This
means that the rust-gpu compiler (<code>rustc_codegen_spirv</code>) will be built in debug
mode, and will be <em>incredibly</em> slow. You can solve this by placing this bit of
configuration in your workspace <code>Cargo.toml</code>:</p>
<pre><code class="language-toml"># Compile build-dependencies in release mode with
# the same settings as regular dependencies.
[profile.release.build-override]
opt-level = 3
codegen-units = 16
[profile.dev.build-override]
opt-level = 3
</code></pre>
<p>Keep in mind this will optimize <em>all</em> build script dependencies as release,
which may slow down full rebuilds a bit. Please read <a href="https://github.com/EmbarkStudios/rust-gpu/issues/448">this
issue</a> for more
information, there's a few important caveats to know about this.</p>
<h3 id="using-cargoconfig"><a class="header" href="#using-cargoconfig">Using <code>.cargo/config</code></a></h3>
<blockquote>
<p><strong>Note</strong> This method will require manually rebuilding <code>rust-gpu</code> each
time there has been changes to the repository.</p>
</blockquote>
<p>If you just want to build a shader crate, and don't need to automatically
compile the SPIR-V binary at build time, you can use <code>.cargo/config</code> to set the
necessary flags. Before you can do that however you need to do a couple of steps
first to build the compiler backend.</p>
<ol>
<li>Clone the <code>rust-gpu</code> repository</li>
<li><code>cargo build --release</code> in <code>rust-gpu</code>.</li>
</ol>
<p>Now you should have a <code>librustc_codegen_spirv</code> dynamic library available in
<code>target/release</code>. You'll need to keep this somewhere stable that you can
reference from your shader project.</p>
<p>Now we need to add our <code>.cargo/config</code> file. This is a configuration file that
tells cargo how to build for SPIR-V. You need provide the target you're
compiling for (see <a href="./platform-support.html">platform support</a>) and provide a path
to your built <code>rustc_codegen_spirv</code> dynamic library. We have to also provide
<code>-Zbuild-std</code>.</p>
<pre><code class="language-toml">[build]
target = &quot;spirv-unknown-spv1.3&quot;
rustflags = [
   &quot;-Zcodegen-backend=&lt;path_to_librustc_codegen_spirv&gt;&quot;,
   &quot;-Csymbol-mangling-version=v0&quot;
]

[unstable]
build-std=[&quot;core&quot;]
build-std-features=[&quot;compiler-builtins-mem&quot;]
</code></pre>
<p>Now we can build our crate with cargo as normal.</p>
<pre><code class="language-bash">cargo build
</code></pre>
<p>Now you should have <code>&lt;project_name&gt;.spv</code> SPIR-V file in <code>target/debug</code> that you
can give to a renderer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attribute-syntax"><a class="header" href="#attribute-syntax">Attribute syntax</a></h1>
<p>rust-gpu introduces a number of SPIR-V related attributes to express behavior specific to SPIR-V not exposed in the base rust language.</p>
<p>There are a few different categories of attributes:</p>
<h2 id="entry-points"><a class="header" href="#entry-points">Entry points</a></h2>
<p>When declaring an entry point to your shader, SPIR-V needs to know what type of function it is. For example, it could be a fragment shader, or vertex shader. Specifying this attribute is also the way rust-gpu knows that you would like to export a function as an entry point, no other functions are exported.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(fragment)]
fn main() { }
</code></pre></pre>
<p>Common values are <code>#[spirv(fragment)]</code> and <code>#[spirv(vertex)]</code>. A list of all supported names can be found in <a href="https://docs.rs/spirv_headers/1.5.0/spirv_headers/enum.ExecutionModel.html">spirv_headers</a> - convert the enum name to snake_case for the rust-gpu attribute name.</p>
<h3 id="compute-shader-dimensions"><a class="header" href="#compute-shader-dimensions">Compute shader dimensions</a></h3>
<p>The dimensions (<code>local_size_*</code> in openGL, <code>numthreads</code> in DX) of a compute shader must be specified (eg. <code>#[spirv(compute(threads(32, 16, 97)))]</code>).  Trailing ones may be elided.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// the x dimension is required
// same as threads(32, 1, 1)
#[spirv(compute(threads(32)))]
pub fn compute_1() {}

// same as threads(32, 57, 1)
#[spirv(compute(threads(32, 57)))]
pub fn compute_2() {}
<span class="boring">}
</span></code></pre></pre>
<h3 id="override-entry-point-name"><a class="header" href="#override-entry-point-name">Override entry point name</a></h3>
<p>You can override the default <code>OpEntryPoint</code> name for any entry point with the <code>entry_point_name</code> sub-attribute on any of the execution model attributes. (e.g. <code>#[spirv(vertex(entry_point_name=&quot;foo&quot;))]</code>)</p>
<h2 id="builtins"><a class="header" href="#builtins">Builtins</a></h2>
<p>When declaring inputs and outputs, sometimes you want to declare it as a &quot;builtin&quot;. This means many things, but one example is <code>gl_Position</code> from glsl - the GPU assigns inherent meaning to the variable and uses it for placing the vertex in clip space. The equivalent in rust-gpu is called <code>position</code>.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(vertex)]
fn main(
    #[spirv(position)] out_pos: &amp;mut Vec4,
) { }
</code></pre></pre>
<p>Common values are <code>#[spirv(position)]</code>, <code>#[spirv(vertex_id)]</code>, and many more. A list of all supported names can be found in <a href="https://docs.rs/spirv_headers/1.5.0/spirv_headers/enum.BuiltIn.html">spirv_headers</a> - convert the enum name to snake_case for the rust-gpu attribute name.</p>
<h2 id="descriptor-set-and-binding"><a class="header" href="#descriptor-set-and-binding">Descriptor set and binding</a></h2>
<p>A SPIR-V shader must declare where uniform variables are located with explicit indices that match up with CPU-side code. This can be done with the <code>descriptor_set</code> and <code>binding</code> attributes. Note that <code>descriptor_set = 0</code> is reserved for future use, and cannot be used.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(fragment)]
fn main(
    #[spirv(uniform, descriptor_set = 2, binding = 5)] var: &amp;mut Vec4,
) { }
</code></pre></pre>
<p>Both descriptor_set and binding take an integer argument that specifies the uniform's index.</p>
<h2 id="flat"><a class="header" href="#flat">Flat</a></h2>
<p>The flat attribute corresponds to the flat keyword in glsl - in other words, the data is not interpolated across the triangle when invoking the fragment shader.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(fragment)]
fn main(#[spirv(flat)] obj: u32) { }
</code></pre></pre>
<h2 id="invariant"><a class="header" href="#invariant">Invariant</a></h2>
<p>The invariant attribute corresponds to the invariant keyword in glsl. It can only be applied to output variables.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(vertex)]
fn main(#[spirv(invariant)] var: &amp;mut f32) { }
</code></pre></pre>
<h2 id="workgroup-shared-memory"><a class="header" href="#workgroup-shared-memory">Workgroup shared memory</a></h2>
<p>The <code>workgroup</code> attribute defines shared memory, which can be accessed by all invocations within the same workgroup. This corresponds to <code>groupshared</code> memory in hlsl or <code>shared</code> memory in glsl.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(compute(threads(32)))]
fn main(#[spirv(workgroup)] var: &amp;mut [Vec4; 4]) { }
</code></pre></pre>
<h2 id="generic-storage-classes"><a class="header" href="#generic-storage-classes">Generic storage classes</a></h2>
<p>The SPIR-V storage class of types is inferred for function signatures. The inference logic can be guided by attributes on the interface specification in the entry points. This also means it needs to be clear from the documentation if an API requires a certain storage class (e.g <code>workgroup</code>) for a variable. Storage class attributes are only permitted on entry points.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-assembly"><a class="header" href="#inline-assembly">Inline Assembly</a></h1>
<p>Rust-GPU has support for inline SPIR-V assembly. In addition the backend
provides several conveniences for writing inline assembly that are documented
below. For more information on specific instruction behaviour and syntax, please
refer to the <a href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html">SPIR-V specification</a>.</p>
<h3 id="basic-syntax--usage"><a class="header" href="#basic-syntax--usage">Basic syntax &amp; usage.</a></h3>
<p>You can write inline assembly using the new <code>asm!</code> macro available with the
<code>asm</code> feature on nightly. Refer to the <a href="https://doc.rust-lang.org/unstable-book/library-features/asm.html">Rust unstable book</a> for more
information on how to use the macro.</p>
<p>Non-ID arguments are written as-is, e.g.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asm! {
    &quot;OpCapability DerivativeControl&quot;
}
<span class="boring">}
</span></code></pre></pre>
<p>ID based arguments are prefixed with <code>%</code> and their name. <code>Result&lt;id&gt;</code>s accessed
with a <code>=</code> and a ID on the left hand side of the expression. E.g.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vector = spirv_std::glam::Vec2::new(1.0, 0.0);
let mut result = f32::default();

asm! {
    &quot;%vector = OpLoad _ {vector}&quot;,
    &quot;%element = OpVectorExtractDynamic _ %vector {index}&quot;,
    &quot;OpStore {element} %element&quot;,
    vector = in(reg) &amp;vector,
    index = in(reg) index,
    element = in(reg) &amp;mut result
}
<span class="boring">}
</span></code></pre></pre>
<p><code>asm!</code> only accepts integers, floats, SIMD vectors, pointers and
function pointers as input variables. However you can have the pointer point
to a generic variable, so you can write generic assembly code like so.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use spirv_std::{scalar::Scalar, vector::Vector};

// This fn is available as `spirv_std::arch::vector_extract_dynamic`
pub unsafe fn vector_extract_dynamic&lt;T: Scalar, V: Vector&lt;T&gt;&gt;(vector: V, index: usize) -&gt; T {
    let mut result = T::default();

    asm! {
        &quot;%vector = OpLoad _ {vector}&quot;,
        &quot;%element = OpVectorExtractDynamic _ %vector {index}&quot;,
        &quot;OpStore {element} %element&quot;,
        vector = in(reg) &amp;vector,
        index = in(reg) index,
        element = in(reg) &amp;mut result
    }

    result
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="additional-syntax"><a class="header" href="#additional-syntax">Additional syntax</a></h3>
<table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody>
<tr><td><code>%&lt;name&gt;</code></td><td>Used to refer to an abstract ID, every unique <code>&lt;name&gt;</code> use generates a new ID.</td></tr>
<tr><td><code>typeof{&lt;variable&gt;}</code></td><td>Returns the type of <code>variable</code></td></tr>
<tr><td><code>_</code> (underscore)</td><td>Equivalent to <code>typeof{&lt;variable&gt;}</code>, but uses inference to determine the variable</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-type-syntax"><a class="header" href="#image-type-syntax">Image type syntax</a></h1>
<p>There are a huge number of combinations of image types in SPIR-V. They are represented by a const
generic type called <code>spirv_std::image::Image</code>, however, specifying the generic parameters of this
type is incredibly tedious, so a wrapper macro, <code>spirv_std::Image!</code> can be used to write the type
instead.</p>
<p>The specific syntax and meaning of the arguments to the <code>Image!</code> macro can be found in
<a href="https://embarkstudios.github.io/rust-gpu/api/spirv_std/macro.Image.html">rustdoc</a>.</p>
<p>Some type aliases for common image formats can be found in the
<a href="https://embarkstudios.github.io/rust-gpu/api/spirv_std/image/index.html"><code>spirv_std::image</code></a>
module. For example, <code>Image2d</code> is a very commonly used type, corresponding to <code>texture2D</code> in GLSL,
and is likely what you want if you want a regular old sampled texture.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Image2d = Image!(2D, type=f32, sampled);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<p>We aught to discuss how we want resource binding to work on a language syntax level.</p>
<h1 id="explanation"><a class="header" href="#explanation">Explanation</a></h1>
<details>
<summary>Small overview of descriptors</summary>
Historically resources such as buffers, textures and samplers have been special in hardware where they were bound to specific slots on the shader core. Usually a limited number of such slots existed, leading to platform and vendor specific limits.
<h3 id="directx"><a class="header" href="#directx">DirectX</a></h3>
<p>In recent years most Desktop platforms have switched to loading resource descriptors from GPU memory instead, this has the major advantage that there is no real limit on the amount of Textures, Buffers and other resource anymore because they all can come from memory. In DirectX12 hardware is divided up into several Tiers which each denominate the amount of descriptors available.</p>
<table><thead><tr><th>Resources Available to the Pipeline</th><th>Tier 1</th><th>Tier 2</th><th>Tier 3</th></tr></thead><tbody>
<tr><td>Feature levels</td><td>11.0+</td><td>11.0+</td><td>11.1+</td></tr>
<tr><td>Maximum number of descriptors in a Constant Buffer View (CBV), Shader Resource View (SRV), or Unordered  Access View(UAV) heap used for rendering</td><td>1,000,000</td><td>1,000,000</td><td>1,000,000+</td></tr>
<tr><td>Maximum number of Constant Buffer Views in all descriptor tables per shader stage</td><td>14</td><td>14</td><td>full heap</td></tr>
<tr><td>Maximum number of Shader Resource Views in all descriptor tables per shader stage</td><td>128</td><td>full heap</td><td>full heap</td></tr>
<tr><td>Maximum number of Unordered Access Views in all descriptor tables across all stages</td><td>64 for feature levels 11.1+ or 8 for feature level</td><td>64</td><td>full heap</td></tr>
<tr><td>Maximum number of Samplers in all descriptor tables per shader stage</td><td>16</td><td>full heap</td><td>full heap</td></tr>
</tbody></table>
<h3 id="vulkan"><a class="header" href="#vulkan">Vulkan</a></h3>
<p>On the other hand in Vulkan resource descriptor binding is designed in such a way that it can accomodate hardware that still relies on descriptor slots instead of memory, because still a lot of such hardware exists in the wild. Especially in the Mobile space.</p>
<p>There are some constraints that currently exist when it comes to binding resources to shaders that we may need to take into account, Vulkan has <code>maxBoundDescriptorSets</code> for example (between 4 and 32). However for the sake of argument we'll ignore these practical limitations for now.</p>
</details>
<h1 id="goal"><a class="header" href="#goal">Goal</a></h1>
<p>Ideally what one would do is have a group of bindings collected together logically for each rendering system; where the bindings are set up (semi-)automatically on both the GPU and CPU.</p>
<p>One thing we'd like to avoid is having a set of names or numbers that manually need to match up between GPU and CPU. </p>
<ol>
<li>Manual numbers (or strings) aren't type-safe.</li>
<li>They make refactoring more difficult (need to change both CPU and GPU side).</li>
<li>They can clash, especially in large code bases where it's difficult to keep track.</li>
</ol>
<h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>I would like us to have an easy way to connect bindings on the GPU and CPU side together, in a way that's as ergonomic to use as possible.</p>
<h2 id="globals"><a class="header" href="#globals">Globals</a></h2>
<details>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(const_generics)]
#![feature(const_fn)]
<span class="boring">fn main() {
</span>use core::marker::PhantomData;

struct Texture&lt;T: Default, const SET: u32, const SLOT: u32&gt; {
    d: PhantomData&lt;T&gt;
}

impl&lt;T: Default, const SET: u32, const SLOT: u32&gt; Texture&lt;T, SET, SLOT&gt; {
    const fn new() -&gt; Self {
        Self {
            d: PhantomData
        }
    }
    
    fn sample(&amp;self, _u: f32, _v: f32) -&gt; T {
        T::default()
    }
}
<span class="boring">}
</span></code></pre></pre>
</details>
<p>This is a more traditional example that's closer to how HLSL or GLSL would do bindings, they have a few generic parameters and it relies on <code>const_generic</code> to function. If we mirror this in existing Rust syntax we'll get something like this:</p>
<pre><pre class="playground"><code class="language-rust">static ALBEDO : Texture::&lt;f32, 0, 0&gt; = Texture::new();
static NORMAL_MAP : Texture::&lt;f32, 0, 1&gt; = Texture::new();
static SMOOTHNESS : Texture::&lt;f32, 0, 2&gt; = Texture::new();
static LIGHTMAP : Texture::&lt;f32, 0, 3&gt; = Texture::new();

fn main() {
    // functions can access the globals directly
    let mut T = brdf();
    T += gi();
}
</code></pre></pre>
<p>This seems to have a few downsides:</p>
<ul>
<li>All caps for the variable/buffer name.</li>
<li>Right now a constructor call is required, and it should be const.</li>
<li>Need to ensure no overlap between sets &amp; slots.</li>
<li>In big code-bases, the dependencies on shaders become very blurred and one needs to inveriable figure out which bindings don't get DCE'd, and more importantly which bindings are actually being used.</li>
<li>If you're using a crate authored by a 3rd-party, it quickly becomes non-obvious which resources need to be bound.</li>
<li>Unclear which downstream call-sites end up requiring more bindings to your SPIR-V blob.</li>
</ul>
<p>And a few upsides:</p>
<ul>
<li>Globals can be accessed anywhere in the program, easily.</li>
</ul>
<p>Alternative would be to remove the <code>const_generic</code> parameters potentially by moving them into the constructor.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static ALBEDO : Texture::&lt;f32&gt; = Texture::new(0, 0);
static NORMAL_MAP : Texture::&lt;f32&gt; = Texture::new(0, 1);
static SMOOTHNESS : Texture::&lt;f32&gt; = Texture::new(0, 2);
static LIGHTMAP : Texture::&lt;f32&gt; = Texture::new(0, 3);
<span class="boring">}
</span></code></pre></pre>
<p>This would make it easier to pass textures to functions (even if they're in different slots) because you'd get something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_system(tex: &amp;Texture::&lt;f32&gt;) {
    let v = tex.sample(0.0, 0.0);
}
<span class="boring">}
</span></code></pre></pre>
<p>Instead of this, which would tightly couple the whole downstream system to have a texture bound to a specific set and slot. This would make changing the bindings later on a nightmare, and wouldn't allow you to conditionally invoke <code>some_system</code> with textures bound to different locations.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_system(tex: &amp;Texture::&lt;f32, 0, 0&gt;) {
    let v = tex.sample(0.0, 0.0);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="arguments-to-main"><a class="header" href="#arguments-to-main">Arguments to <code>main</code></a></h2>
<p>Most compute-only languages tend to prefer this along with positional binding. This makes &quot;invoking a shader&quot; look much more like a function call and uses existing and familiar semantics.</p>
<pre><pre class="playground"><code class="language-rust">fn main(albedo: Texture::&lt;f32&gt;, normal_map: Texture::&lt;f32&gt;, smoothness: Texture::&lt;f32&gt;, lightmap: Texture&lt;f32&gt;) {
    let mut T = brdf(&amp;albedo, &amp;normal_map, &amp;smoothness);
    T += gi(&amp;lightmap);
}
</code></pre></pre>
<p>Doing this straight up has a few downsides:</p>
<ul>
<li>Big kernels/shader can have lots of buffers and textures bound making this list potentially large.</li>
<li>Need to pass down all bindings all the way to leaf-node systems.</li>
</ul>
<p>Some upsides:</p>
<ul>
<li>No clashes for sets/slots since the language takes care of this.</li>
<li>It's clear from the get-go which bindings are being used.</li>
</ul>
<p>A much nicer and more ergonomic approach would be to store texture bindings in structs:</p>
<pre><pre class="playground"><code class="language-rust">struct ShadingInputs {
    albedo: Texture::&lt;f32&gt;,
    normal_map: Texture::&lt;f32&gt;,
    smoothness: Texture::&lt;f32&gt;,
}

struct IndirectLighting {
    lightmap: Texture&lt;f32&gt;,
}

fn main(inputs: &amp;ShadingInputs, indirect_lighting: &amp;IndirectLighting) {
    let mut T = brdf(&amp;inputs);
    T += gi(&amp;indirect_lighting);
}
</code></pre></pre>
<h1 id="suggestion"><a class="header" href="#suggestion">Suggestion</a></h1>
<p>I think the most ergonomic and future proof binding method would be to have descriptors in structs, bound to the entrypoint. This allows us some nice, even more ergonomic upsides later on (when support is more widely available) where we can put data members in these structs as well. And along with this, we can have very egonomic CPU side code as well, where we can keep shader invocation looking like a function call for a large part, instead of having to manually bind to slots again.</p>
<h1 id="prior-art"><a class="header" href="#prior-art">Prior art</a></h1>
<details>
<h2 id="metal"><a class="header" href="#metal">Metal</a></h2>
<p>Metal has argument buffers, best described here: https://developer.apple.com/documentation/metal/buffers/about_argument_buffers</p>
<h2 id="hlsl"><a class="header" href="#hlsl">HLSL</a></h2>
<p>Resource binding in HLSL is done by declaring a set of special case globals that make up resource descriptors on the GPU. </p>
<pre><code class="language-hlsl">Texture2D&lt;float4&gt; tex0          : register(t5,  space0);
Texture2D&lt;float4&gt; tex1[][5][3]  : register(t10, space0);
Texture2D&lt;float4&gt; tex2[8]       : register(t0,  space1);
SamplerState samp0              : register(s5, space0);
ConstantBuffer&lt;myConstants&gt;   c[10000] : register(b0);
</code></pre>
<p>In DirectX12 the feature of Root Signatures got added that is essentially a new domain specific language to set up the layout / calling convention of the shader; specified in a string.</p>
<p>Note the the two examples don't match necessarily. </p>
<pre><code class="language-hlsl">#define MyRS1 &quot;RootFlags( ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT | &quot; \
                         &quot;DENY_VERTEX_SHADER_ROOT_ACCESS), &quot; \
              &quot;CBV(b0, space = 1, flags = DATA_STATIC), &quot; \
              &quot;SRV(t0), &quot; \
              &quot;UAV(u0), &quot; \
              &quot;DescriptorTable( CBV(b1), &quot; \
                               &quot;SRV(t1, numDescriptors = 8, &quot; \
                               &quot;        flags = DESCRIPTORS_VOLATILE), &quot; \
                               &quot;UAV(u1, numDescriptors = unbounded, &quot; \
                               &quot;        flags = DESCRIPTORS_VOLATILE)), &quot; \
              &quot;DescriptorTable(Sampler(s0, space=1, numDescriptors = 4)), &quot; \
              &quot;RootConstants(num32BitConstants=3, b10), &quot; \
              &quot;StaticSampler(s1),&quot; \
              &quot;StaticSampler(s2, &quot; \
                             &quot;addressU = TEXTURE_ADDRESS_CLAMP, &quot; \
                             &quot;filter = FILTER_MIN_MAG_MIP_LINEAR )&quot;
</code></pre>
<h2 id="glsl"><a class="header" href="#glsl">GLSL</a></h2>
<pre><code class="language-glsl">uniform texture2D inputTex;
uniform restrict writeonly uimage2D outputTex;

layout(std430) buffer mesh_color_buf {
    vec4 colors[];
};

layout(std430) buffer mesh_vertex_buf {
    VertexPacked vertices[];
};
</code></pre>
<h2 id="cuda"><a class="header" href="#cuda">CUDA</a></h2>
<p>In CUDA most resources are bound to the kernel's entry point - e.g. buffers are just passed as pointers etc. </p>
<h2 id="opencl"><a class="header" href="#opencl">OpenCL</a></h2>
<p>In OpenCL resources are marked up with their address spaces and also passed as function arguments to the executing kernel. Resources like buffers look like pointers but a lot of compiler magic is going on to turn them from resource descriptors (such as the GCN V#) into something that can emulate pointers.</p>
<h2 id="rlsl"><a class="header" href="#rlsl">RLSL</a></h2>
<p>RLSL also passes resource bindings as arguments to the kernel, with two template parameters. One for the <code>set</code> and one for the <code>space</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[spirv(compute)]
fn compute(compute: Compute, buffer: Buffer&lt;N0, N0, RuntimeArray&lt;f32&gt;&gt;)
<span class="boring">}
</span></code></pre></pre>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
