<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust GPU Dev Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Contributing to Rust-GPU</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="building-rust-gpu.html"><strong aria-hidden="true">2.1.</strong> Building</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">2.2.</strong> Testing</a></li><li class="chapter-item expanded "><a href="codegen-args.html"><strong aria-hidden="true">2.3.</strong> "Codegen args" (flags/options) supported by the Rust-GPU codegen backend</a></li><li class="chapter-item expanded "><a href="spirv-minimization.html"><strong aria-hidden="true">2.4.</strong> Minimizing bugs in SPIR-V</a></li><li class="chapter-item expanded "><a href="publishing-rust-gpu.html"><strong aria-hidden="true">2.5.</strong> Publishing Rust-GPU on crates.io</a></li></ol></li><li class="chapter-item expanded "><a href="platform-support.html"><strong aria-hidden="true">3.</strong> Platform Support</a></li><li class="chapter-item expanded "><a href="writing-shader-crates.html"><strong aria-hidden="true">4.</strong> Writing Shader Crates</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Features</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="attributes.html"><strong aria-hidden="true">5.1.</strong> Attribute syntax</a></li><li class="chapter-item expanded "><a href="inline-asm.html"><strong aria-hidden="true">5.2.</strong> Inline Assembly</a></li><li class="chapter-item expanded "><a href="image.html"><strong aria-hidden="true">5.3.</strong> Image type syntax</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust GPU Dev Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the Rust-GPU dev guide! This documentation is meant for documenting
how to use and develop on Rust-GPU.</p>
<p>If you're looking to get started with writing your own shaders in Rust,
check out the <a href="./writing-shader-crates.html"><em>"Writing Shader Crates"</em></a> section for
more information on how to get started.</p>
<p>Alternatively if you're looking to contribute to the <code>rust-gpu</code> project, have
a look at <a href="./building-rust-gpu.html"><em>"Building Rust-GPU"</em></a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-rust-gpu"><a class="header" href="#building-rust-gpu">Building Rust-GPU</a></h1>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<ol>
<li>
<p>Clone the repository.</p>
<pre><code class="language-shell">git clone --recurse-submodules https://github.com/EmbarkStudios/rust-gpu
</code></pre>
</li>
<li>
<p><strong>optional</strong> Install <a href="https://github.com/KhronosGroup/SPIRV-Tools#downloads">SPIRV-Tools</a> and add it to your <code>PATH</code>. You can skip this step if you just want to run examples with the defaults. See <a href="building-rust-gpu.html#using-installed-spirv-tools">Using installed SPIRV-Tools</a> if you decide to go with this option.</p>
</li>
<li>
<p>Next, look at the <a href="https://github.com/EmbarkStudios/rust-gpu/tree/main/examples">examples</a> folder. There are two kinds of targets here: [runners] and [shaders]. The projects inside <code>shaders</code> are "GPU crates", i.e. ones that will be compiled to one or more SPIR-V modules. The <code>runner</code> projects are normal, CPU crates that use some graphics backend (currently, we have a <a href="https://github.com/EmbarkStudios/rust-gpu/tree/main/examples/runners/wgpu"><code>wgpu</code> runner</a>, a <a href="https://github.com/EmbarkStudios/rust-gpu/tree/main/examples/runners/ash">Vulkan runner</a> through <code>ash</code>, and a barebones pure software <a href="https://github.com/EmbarkStudios/rust-gpu/tree/main/examples/runners/cpu">CPU runner</a>) to actually run one of the "GPU crate" shaders.</p>
<p>Run the example:</p>
<pre><code class="language-shell">cargo run --bin example-runner-wgpu
</code></pre>
<p>This will build <code>rustc_codegen_spirv</code>, the compiler, then use that compiler to build <a href="examples/shaders/sky-shader"><code>sky-shader</code></a> into a SPIR-V module, then finally, build a <code>wgpu</code> sample app (modified from <a href="https://github.com/gfx-rs/wgpu-rs/tree/master/examples/hello-triangle"><code>wgpu</code>'s examples</a>) using the built SPIR-V module to display the shader in a window.</p>
</li>
</ol>
<h2 id="prerequisite-linux-packages-recommended-to-install-before-building-rust-gpu"><a class="header" href="#prerequisite-linux-packages-recommended-to-install-before-building-rust-gpu">Prerequisite linux packages recommended to install before building Rust-GPU</a></h2>
<p>You may need the development version (i.e. headers/etc. included) of some packages in some distributions to be able to
build the examples - specifically, x11 and libxkbcommon, as well as gcc/clang with c++ support. These packages may be
called (fedora) <code>libX11-devel</code>, <code>libxkbcommon-x11-devel</code>, and <code>gcc-c++</code>, or (ubuntu) <code>libxkbcommon-x11-dev</code>,
<code>libx11-dev</code>, and <code>gcc</code>.</p>
<h2 id="using-installed-spirv-tools"><a class="header" href="#using-installed-spirv-tools">Using installed SPIRV-Tools</a></h2>
<p>By default, all of the crates and examples in this repo will compile the <a href="https://crates.io/crates/spirv-tools-sys"><code>spirv-tools-sys</code></a> crate, including a lot of C++ code from <a href="https://github.com/EmbarkStudios/SPIRV-Tools">SPIRV-Tools</a>. If you don't want to build the C++ code because you already have <a href="https://github.com/KhronosGroup/SPIRV-Tools#downloads">SPIRV-Tools</a> installed, or just don't want to spend more time compiling, you can build/run the crate with the <code>use-installed-tools</code> feature.</p>
<pre><code class="language-shell">cargo run \
    --manifest-path examples/example-runner/Cargo.toml \
    --features use-installed-tools \
    --no-default-features
</code></pre>
<p>You should see <code>warning: use-installed-tools feature on, skipping compilation of C++ code</code> during the compilation, but otherwise the build will function just the same as if you compiled the C++ code, with the exception that it will fail if you don't have SPIRV-Tools installed correctly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-rust-gpu"><a class="header" href="#testing-rust-gpu">Testing Rust-GPU</a></h1>
<p>Rust-GPU has a couple of different kinds of tests, most can be ran through
<code>cargo test</code>, however Rust-GPU also has end-to-end tests for compiling Rust and
validating its SPIR-V output, which can ran by running <code>cargo compiletest</code>.</p>
<pre><code class="language-bash">cargo test &amp;&amp; cargo compiletest
</code></pre>
<h2 id="adding-tests"><a class="header" href="#adding-tests">Adding Tests</a></h2>
<p>Rust-GPU's end-to-end test's use an external version of the <a href="https://github.com/laumann/compiletest-rs"><code>compiletest</code></a> tool
as a testing framework. Be sure to check out the <a href="https://github.com/laumann/compiletest-rs">repository</a> and
the <a href="https://rustc-dev-guide.rust-lang.org/tests/intro.html">rustc Dev-Guide</a> for more information about how it works,
how to configure it, and add new tests.</p>
<h3 id="blessing-tests"><a class="header" href="#blessing-tests">Blessing Tests</a></h3>
<p>You will occassionally need to "bless" the output from UI tests to update the
normalised output, you can do this by passing a <code>--bless</code> flag to
<code>cargo compiletest</code>.</p>
<pre><code class="language-bash">cargo compiletest --bless
</code></pre>
<h3 id="filtering-tests"><a class="header" href="#filtering-tests">Filtering Tests</a></h3>
<p>When working on tests, you may need to run <code>cargo compiletest</code> a few times,
while changing only a small number of tests. You can avoid having to run all
the other (unrelated) tests, by passing substrings of their paths, to
<code>cargo compiletest</code>, for example:</p>
<pre><code class="language-bash">cargo compiletest arch/u image
</code></pre>
<p>The above command will only test <code>ui/arch/u_*.rs</code> and <code>ui/image/*.rs</code>, and skip
everything else. You can also add <code>--bless</code> to update expected outputs, as well.</p>
<h3 id="testing-different-environments"><a class="header" href="#testing-different-environments">Testing Different Environments</a></h3>
<p>You can test against multiple different SPIR-V environments with the
<code>--target-env</code> flag. By default it is set to <code>unknown</code>.</p>
<pre><code class="language-bash">cargo compiletest --target-env=vulkan1.1
# You can also provide multiple values to test multiple environments
cargo compiletest --target-env=vulkan1.1,spv.1.3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="codegen-args-flagsoptions-supported-by-the-rust-gpu-codegen-backend"><a class="header" href="#codegen-args-flagsoptions-supported-by-the-rust-gpu-codegen-backend">"Codegen args" (flags/options) supported by the Rust-GPU codegen backend</a></h1>
<p>Please keep in mind that many of these flags/options are for internal development, and may break output
unexpectedly and generally muck things up. Please only use these if you know what you're doing.</p>
<p>Help is also appreciated keeping this document up to date, "codegen args" flags/options may be
added/removed on an ad-hoc basis without much thought, as they're internal development tools, not a
public API - this documentation is only here because these flags/options may be helpful diagnosing
problems for others.</p>
<p>It's recommended that "codegen args" options that take paths to files or directories are set to full
paths, as the working directory of the compiler might be something wonky and unexpected, and it's
easier to set the full path.</p>
<hr />
<h2 id="how-to-set-codegen-args-flagsoptions"><a class="header" href="#how-to-set-codegen-args-flagsoptions">How to set "codegen args" flags/options</a></h2>
<p>The most convenient method is relying on <code>spirv-builder</code> reading the <code>RUSTGPU_CODEGEN_ARGS</code> environment variable, e.g.:</p>
<pre><code class="language-console">$ RUSTGPU_CODEGEN_ARGS="--no-spirv-val --dump-post-link=$PWD/postlink" cargo run -p example-runner-wgpu
...
    Finished release [optimized] target(s) in 15.15s

$ file postlink/*
postlink/module: Khronos SPIR-V binary, little-endian, version 0x010300, generator 0x1b0000
</code></pre>
<p>Notably, <code>RUSTGPU_CODEGEN_ARGS="--help"</code> can be used to see a "usage" message (which lists all the flags/options, including ones not listed in this document), via e.g. running a Cargo build that relies on <code>spirv-builder</code>.</p>
<p>However, it's only a convenient alias for for <code>RUSTGPU_RUSTFLAGS=-Cllvm-args="..."</code> (without having to expose the fact that LLVM's name is still attached to <code>rustc</code>'s interface for this functionality), and if in direct control of <code>rustc</code>, you can still pass such "codegen args" flags/options wrapped in <code>-C llvm-args="..."</code>.</p>
<hr />
<h2 id="historical-note-about-past-environment-variables"><a class="header" href="#historical-note-about-past-environment-variables">Historical note about past "environment variables"</a></h2>
<p>Many of these flags/options were at one point, individual environment variable (e.g. the <code>--dump-pre-link</code> option used to be the environment variable <code>DUMP_PRE_LINK</code>).</p>
<p>However, that approach is prone to various failure modes, because the environment variables would not get registered as a "dependency" (without extra work that never happened), and the idea of "codegen args" fits better with existing practices (e.g. <code>rustc -C llvm-args="..."</code> for the LLVM codegen backend of <code>rustc</code>).</p>
<p>For more context see also <a href="https://github.com/EmbarkStudios/rust-gpu/pull/959">PR #959</a>, which made the transition to this system.</p>
<h2 id="where-are-all-the-rest-of-the-flagsoptions-documented"><a class="header" href="#where-are-all-the-rest-of-the-flagsoptions-documented">Where are all the rest of the flags/options documented?</a></h2>
<p>If you do run a build with <code>RUSTGPU_CODEGEN_ARGS="--help"</code> (or <code>-C llvm-args="--help"</code>), you will notice more flags/options than are listed in this documented.</p>
<p>This is a historical artifact: as mentioned above, these used to be environment variables, and this document only described those, without talking about the older "codegen args" at all.</p>
<p>While most of those flags are usually only exposed through higher-level <code>spirv-builder</code> APIs, it would be nice to have all of them documented in one place (eventually?).</p>
<hr />
<h2 id="debugging-codegen-args-flagsoptions"><a class="header" href="#debugging-codegen-args-flagsoptions">Debugging "codegen args" flags/options</a></h2>
<p>As mentioned above, these form the bulk of "codegen args", but keep in mind the list is not exhaustive and you will want to cehck the full list with e.g. <code>RUSTGPU_CODEGEN_ARGS="--help"</code>.</p>
<h3 id="--dump-mir-dir"><a class="header" href="#--dump-mir-dir"><code>--dump-mir DIR</code></a></h3>
<p>Dumps the MIR of every function rust-gpu encounters, to files in <code>DIR</code>. Yes, rustc does have options to do
this by default, but I always forget the syntax, and plumbing through the option to <code>spirv-builder</code>
is annoying, so this is handy to just hack an output.</p>
<p><em><strong>FIXME(@eddyb)</strong> this may be irrelevant now given <code>RUSTGPU_RUSTFLAGS</code></em></p>
<h3 id="--dump-module-on-panic-file"><a class="header" href="#--dump-module-on-panic-file"><code>--dump-module-on-panic FILE</code></a></h3>
<p>If codegen panics, then write the (partially) emitted module to <code>FILE</code>. Note that this only exists
for codegen, if the linker panics, this option does nothing, sadly.</p>
<h3 id="--dump-pre-link-dir"><a class="header" href="#--dump-pre-link-dir"><code>--dump-pre-link DIR</code></a></h3>
<p>Dumps all input modules to the linker, to files in <code>DIR</code>, before the linker touches them at all.</p>
<h3 id="--dump-post-merge-dir"><a class="header" href="#--dump-post-merge-dir"><code>--dump-post-merge DIR</code></a></h3>
<p>Dumps the merged module, to a file in <code>DIR</code>, immediately after merging, but before the linker has done anything else
(including, well, linking the methods - <code>LinkageAttributes</code> will still exist, etc.). This is very
similar to <code>--dump-pre-link</code>, except it outputs only a single file, which might make grepping through
for stuff easier.</p>
<h3 id="--dump-post-split-dir"><a class="header" href="#--dump-post-split-dir"><code>--dump-post-split DIR</code></a></h3>
<p>Dumps the modules, to files in <code>DIR</code>, immediately after multimodule splitting, but before final cleanup passes (e.g.
DCE to remove the other entry points).</p>
<h3 id="--dump-post-link-dir"><a class="header" href="#--dump-post-link-dir"><code>--dump-post-link DIR</code></a></h3>
<p>Takes: path to directory</p>
<p>Dumps all output modules from the linker, to files in <code>DIR</code>. This may be multiple files due to the multimodule/module
splitting option, hence it takes a directory instead of a file path. This is the final output
binary before <code>spirv-opt</code> is executed, so it may be useful to output this to check if an issue is in
Rust-GPU, or in <code>spirv-opt</code>.</p>
<h3 id="--specializer-debug"><a class="header" href="#--specializer-debug"><code>--specializer-debug</code></a></h3>
<p>Enables debug logging for the specializer.</p>
<p><em><strong>FIXME(@eddyb)</strong> use <code>log</code>/<code>tracing</code> instead for this purpose</em></p>
<h3 id="--specializer-dump-instances-file"><a class="header" href="#--specializer-dump-instances-file"><code>--specializer-dump-instances FILE</code></a></h3>
<p>Dumps to <code>FILE</code> all instances inferred by the specializer.</p>
<h3 id="--print-zombie"><a class="header" href="#--print-zombie"><code>--print-zombie</code></a></h3>
<p>Prints to rustc stdout which functions were removed due to being zombies, and why.</p>
<p><em><strong>FIXME(@eddyb)</strong> use <code>log</code>/<code>tracing</code> instead for this purpose</em></p>
<h3 id="--print-all-zombie"><a class="header" href="#--print-all-zombie"><code>--print-all-zombie</code></a></h3>
<p>Prints to rustc stdout <em>everything</em> that was removed due to being zombies, why, and if it was an
original zombie or if it was infected. (prints a lot!)</p>
<p><em><strong>FIXME(@eddyb)</strong> use <code>log</code>/<code>tracing</code> instead for this purpose</em></p>
<h3 id="--no-spirv-val"><a class="header" href="#--no-spirv-val"><code>--no-spirv-val</code></a></h3>
<p>Disables running <code>spirv-val</code> on the final output. Spooky scary option, can cause invalid modules!</p>
<h3 id="--no-spirv-opt"><a class="header" href="#--no-spirv-opt"><code>--no-spirv-opt</code></a></h3>
<p>Forcibly disables running <code>spirv-opt</code> on the final output, even if optimizations are enabled.</p>
<h3 id="--no-dce"><a class="header" href="#--no-dce"><code>--no-dce</code></a></h3>
<p>Disables running dead code elimination. Can and probably will generate invalid modules or crash the
linker, hasn't been tested for a while.</p>
<h3 id="--no-compact-ids"><a class="header" href="#--no-compact-ids"><code>--no-compact-ids</code></a></h3>
<p>Disables compaction of SPIR-V IDs at the end of linking. Causes absolutely ginormous IDs to be
emitted. Useful if you're println debugging IDs in the linker (although spirv-opt will compact them
anyway, be careful).</p>
<h3 id="--no-early-report-zombies"><a class="header" href="#--no-early-report-zombies"><code>--no-early-report-zombies</code></a></h3>
<p>Delays reporting zombies (aka "deferred errors") even further, to allow more legalization.
Currently this also replaces the zombie reporting with a SPIR-T-based version
(which may become the default in the future).</p>
<h3 id="--no-infer-storage-classes"><a class="header" href="#--no-infer-storage-classes"><code>--no-infer-storage-classes</code></a></h3>
<p>Disables the old SPIR-V "Storage Class" (i.e. address space) inference pass,
to allow testing alternatives to it (such as SPIR-T <code>qptr</code> passes).</p>
<p>Note that this will produce illegal SPIR-V by default, and you need e.g.
<code>--spirt-passes=qptr</code> in order to regain legal "Storage Class" assignments<br />
(see <a href="https://github.com/EmbarkStudios/spirt/pull/24">SPIR-T <code>qptr</code> PR</a> for more information on <code>qptr</code> in general)</p>
<h3 id="--no-structurize"><a class="header" href="#--no-structurize"><code>--no-structurize</code></a></h3>
<p>Disables CFG structurization. Probably results in invalid modules.</p>
<h3 id="--spirt-until-060"><a class="header" href="#--spirt-until-060"><code>--spirt</code> <sub><em>(until 0.6.0)</em></sub></a></h3>
<p><del>Note: as of <code>rust-gpu 0.6.0</code>, <code>SPIR-ðŸ‡¹</code> is enabled by default. Use <code>--no-spirt</code> to disable.</del>
Note: as of <code>rust-gpu 0.8.0</code>, <code>SPIR-ðŸ‡¹</code> is always being used and cannot be disabled
(to reduce the cost of maintenance, testing and further feature development).</p>
<p>Enables using the experimental <a href="https://github.com/EmbarkStudios/spirt"><code>SPIR-ðŸ‡¹</code> shader IR framework</a> in the linker - more specifically, this:</p>
<ul>
<li>adds a <code>SPIR-V -&gt; SPIR-ðŸ‡¹ -&gt; SPIR-V</code> roundtrip<br />
(future <code>SPIR-ðŸ‡¹</code> passes would go in the middle of this, and eventually codegen might not produce <code>SPIR-V</code> at all)</li>
<li>replaces the existing structurizer with <code>SPIR-ðŸ‡¹</code> structurization (which is more robust and can e.g. handle <code>OpPhi</code>s)</li>
<li>runs some existing <code>SPIR-V</code> legalization/optimization passes (<code>mem2reg</code>) <em>before</em> inlining, instead of <em>only after</em> (as the <code>OpPhi</code>s they would produce are no longer an issue for structurization)</li>
</ul>
<p>For more information, also see <a href="https://github.com/EmbarkStudios/spirt">the <code>SPIR-ðŸ‡¹</code> repository</a>.</p>
<h3 id="--no-spirt-060-and-070"><a class="header" href="#--no-spirt-060-and-070"><code>--no-spirt</code> <sub><em>(0.6.0 and 0.7.0)</em></sup></a></h3>
<p>Note: as of <code>rust-gpu 0.8.0</code>, <code>SPIR-ðŸ‡¹</code> is always being used and cannot be disabled
(to reduce the cost of maintenance, testing and further feature development).</p>
<p>Note: if you were using <code>--no-spirt</code> to work around <a href="https://github.com/gfx-rs/naga/issues/1977"><code>naga</code> issue #1977</a><br />
(valid loops causing <code>The 'break' is used outside of a 'loop' or 'switch' context</code>),<br />
you may be able to <code>cargo update -p naga</code> to update to a fixed <code>naga</code> version<br />
(<code>0.11.1</code> for <code>wgpu 0.15</code>, <code>0.12.1</code> for <code>wgpu 0.16</code>, and any later versions).</p>
<p>Disables the <a href="https://github.com/EmbarkStudios/spirt"><code>SPIR-ðŸ‡¹</code> shader IR framework</a> in the linker.</p>
<h3 id="--spirt-passes-passes"><a class="header" href="#--spirt-passes-passes"><code>--spirt-passes PASSES</code></a></h3>
<p>Enable additional <code>SPIR-ðŸ‡¹</code> passes, as listed in <code>PASSES</code> (comma-separated).<br />
Their implementation can be found in <a href="../../crates/rustc_codegen_spirv/src/linker/spirt_passes"><code>rustc_codegen_spirv::linker::spirt_passes</code></a>.</p>
<p><em>Note: passes that are not already enabled by default are considered experimental and likely not ready for production use, this flag exists primarily for testing.</em></p>
<h3 id="--dump-spirt-passes-dir"><a class="header" href="#--dump-spirt-passes-dir"><code>--dump-spirt-passes DIR</code></a></h3>
<p>Dump the <code>SPIR-ðŸ‡¹</code> module across passes (i.e. all of the versions before/after each pass), as a combined report, to a pair of files (<code>.spirt</code> and <code>.spirt.html</code>) in <code>DIR</code>.<br />
<sub>(the <code>.spirt.html</code> version of the report is the recommended form for viewing, as it uses tabling for versions, syntax-highlighting-like styling, and use-&gt;def linking)</sub></p>
<h3 id="--spirt-strip-custom-debuginfo-from-dumps"><a class="header" href="#--spirt-strip-custom-debuginfo-from-dumps"><code>--spirt-strip-custom-debuginfo-from-dumps</code></a></h3>
<p>When dumping (pretty-printed) <code>SPIR-ðŸ‡¹</code> (e.g. with <code>--dump-spirt-passes</code>), strip
all the custom (Rust-GPU-specific) debuginfo instructions, by converting them
to the standard SPIR-V debuginfo (which <code>SPIR-ðŸ‡¹</code> understands more directly).</p>
<p>The default (keeping the custom instructions) is more verbose, but also lossless,
if you want to see all instructions exactly as e.g. <code>--spirt-passes</code> see them.</p>
<h3 id="--spirt-keep-debug-sources-in-dumps"><a class="header" href="#--spirt-keep-debug-sources-in-dumps"><code>--spirt-keep-debug-sources-in-dumps</code></a></h3>
<p>When dumping (pretty-printed) <code>SPIR-ðŸ‡¹</code> (e.g. with <code>--dump-spirt-passes</code>), preserve
all the "file contents debuginfo" (i.e. from SPIR-V <code>OpSource</code> instructions),
which will end up being included, in full, at the start of the dump.</p>
<p>The default (of hiding the file contents) is less verbose, but (arguably) lossier.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="minimizing-bugs-in-spir-v"><a class="header" href="#minimizing-bugs-in-spir-v">Minimizing bugs in SPIR-V</a></h1>
<p>When debugging problems with SPIR-V generated by rust-gpu, you occasionally need
to reduce the SPIR-V in order to make it easily shareable with others. We've
created a short guide on how to do that.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>In order to build and validate SPIR-V you're going to install <a href="https://github.com/KhronosGroup/SPIRV-Tools#downloads">SPIR-V
tools</a>.</p>
<h2 id="spir-v-template"><a class="header" href="#spir-v-template">SPIR-V Template</a></h2>
<p>SPIR-V has some amount of required boilerplate in order to be considered valid,
we've created a small template to help to get started. This file creates a
single empty vertex entry-point with a single floating-point constant.</p>
<pre><code class="language-spirv">; bug.spvasm
OpCapability Shader
OpCapability VulkanMemoryModel
OpMemoryModel Logical Vulkan

; == Entry-points ==
OpEntryPoint Vertex %vert_fn "vert"

; == Types ==
%void = OpTypeVoid
%f32 = OpTypeFloat 32

; Function Types
%void_fn = OpTypeFunction %void

; == Constants ==
%f32_1 = OpConstant %f32 1

; == Functions ==
%vert_fn = OpFunction %void None %void_fn
  %block = OpLabel
    OpReturn
OpFunctionEnd
</code></pre>
<h2 id="steps"><a class="header" href="#steps">Steps</a></h2>
<ol>
<li>
<p>Assemble your spirv with <code>spirv-as ./bug.spvasm</code>, this will produce a
<code>out.spv</code> file containing the assembled code.</p>
</li>
<li>
<p>The assembled code also needs to be validated with <code>spirv-val out.spv</code></p>
</li>
<li>
<p>Once the code has been validated as having no issues, you can use
<code>spirv-cross</code> to compile the code to various outputs.</p>
<ul>
<li><strong>GLSL</strong> <code>spirv-cross out.spv</code></li>
<li><strong>HLSL</strong> <code>spirv-cross --hlsl out.spv</code></li>
<li><strong>MSL</strong> <code>spirv-cross --msl out.spv</code></li>
<li><strong>Vulkan GLSL</strong> <code>spirv-cross -V out.spv</code></li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-rust-gpu-on-cratesio"><a class="header" href="#publishing-rust-gpu-on-cratesio">Publishing rust-gpu on crates.io</a></h1>
<p>This is a task list for the maintainers of rust-gpu to remember to do when publishing a new version
of rust-gpu (probably not useful for contributors without access to embark's crates.io account ðŸ˜‹)</p>
<p>The published crates and their relative locations are:</p>
<ol>
<li><code>spirv-std-types</code> (<code>crates/spirv-std/shared</code>)</li>
<li><code>spirv-std-macros</code> (<code>crates/spirv-std/macros</code>)</li>
<li><code>spirv-std</code> (<code>crates/spirv-std</code>)</li>
<li><code>rustc_codegen_spirv-types</code> (<code>crates/rustc_codegen_spirv-types</code>)</li>
<li><code>rustc_codegen_spirv</code> (<code>crates/rustc_codegen_spirv</code>)</li>
<li><code>spirv-builder</code> (<code>crates/spirv-builder</code>)</li>
</ol>
<p>Publishing the crates in above order prevents dependency issues.
These are the steps:</p>
<ol>
<li>Bump all the versions to the next one in the workspace's <code>Cargo.toml</code>. This project uses workspace
inheritance, so this is the only place you'll find these actual versions. Make sure to pin the
rust-gpu dependencies to their <em>exact</em> versions using the <code>=</code>-notation, such as: <code>=0.4.0</code>. All crates
are built and published in tandem so you're not expected to be able to mix and match between versions.</li>
<li>Add this new version to the table in <code>crates/spirv-builder/README.md</code> and make sure the correct
nightly version is listed there as well.</li>
<li>Create a PR with that change. Wait for CI and a review, and merge it.</li>
<li>Pull the merged <code>main</code> branch.</li>
<li>Tag <code>main</code> with the version: <code>git tag v0.4.0</code></li>
<li>Push the tag: <code>git push origin v0.4.0</code></li>
<li>Publish the crates: <code>cd [crate] &amp;&amp; cargo publish</code> in the order of the list above (make sure
<code>.cargo/credentials</code> is set to embark's token). The crates.io index might take some seconds to update
causing an error if the crates are published in quick succession. Wait a couple of seconds and try
again ðŸ™‚.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h1>
<p>The <code>rust-gpu</code> project currently supports a limited number of platforms and graphics APIs. Right now we're not distributing build artifacts and we're primarily focused on the development of the project, so this is based on the current <code>main</code> branch. There are a lot of different configurations and hardware out there to support, this document is intended to document what is currently supported, what we intend to support, and what isn't supported. Over time as the project stabilises and our CI improves, more platforms and APIs will be supported and tested. Currently support for each topic is divided into the following three categories.</p>
<ul>
<li><strong>Primary â€”</strong> Built and tested on CI.</li>
<li><strong>Secondary â€”</strong> Built but <em>not fully tested</em> on CI.</li>
<li><strong>Tertiary â€”</strong> Present in the codebase but not built or tested.</li>
</ul>
<h2 id="operating-system"><a class="header" href="#operating-system">Operating System</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operating System</th><th>Version</th><th>Support</th><th>Notes</th></tr></thead><tbody>
<tr><td>Windows</td><td>10+</td><td>Primary</td><td></td></tr>
<tr><td>Linux</td><td>Ubuntu 18.04+</td><td>Primary</td><td></td></tr>
<tr><td>macOS</td><td>Catalina (10.15)+</td><td>Secondary</td><td>Using <a href="https://github.com/KhronosGroup/MoltenVK">MoltenVK</a>, requires v1.1.2+</td></tr>
<tr><td>Android</td><td>Tested 10-11</td><td>Secondary</td><td></td></tr>
</tbody></table>
</div>
<h2 id="graphics-apis"><a class="header" href="#graphics-apis">Graphics APIs</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Version</th><th>Support</th><th>Notes</th></tr></thead><tbody>
<tr><td>SPIR-V</td><td>1.3+</td><td>Primary</td><td></td></tr>
<tr><td>Vulkan</td><td>1.1+</td><td>Primary</td><td></td></tr>
<tr><td>WGPU</td><td>0.6</td><td>Primary</td><td>Uses a translation layer to Metal/DX12</td></tr>
<tr><td>OpenGL</td><td>???</td><td>Tertiary</td><td></td></tr>
</tbody></table>
</div>
<h3 id="spir-v-targets"><a class="header" href="#spir-v-targets">SPIR-V Targets</a></h3>
<ul>
<li><code>spirv-unknown-spv1.0</code></li>
<li><code>spirv-unknown-spv1.1</code></li>
<li><code>spirv-unknown-spv1.2</code></li>
<li><code>spirv-unknown-spv1.3</code></li>
<li><code>spirv-unknown-spv1.4</code></li>
<li><code>spirv-unknown-spv1.5</code></li>
</ul>
<h3 id="vulkan-targets"><a class="header" href="#vulkan-targets">Vulkan Targets</a></h3>
<ul>
<li><code>spirv-unknown-vulkan1.0</code></li>
<li><code>spirv-unknown-vulkan1.1</code></li>
<li><code>spirv-unknown-vulkan1.1spv1.4</code></li>
<li><code>spirv-unknown-vulkan1.2</code></li>
</ul>
<h3 id="webgpu-targets"><a class="header" href="#webgpu-targets">WebGPU Targets</a></h3>
<ul>
<li><code>spirv-unknown-webgpu0</code></li>
</ul>
<h3 id="opengl-targets"><a class="header" href="#opengl-targets">OpenGL Targets</a></h3>
<ul>
<li><code>spirv-unknown-opengl4.0</code></li>
<li><code>spirv-unknown-opengl4.1</code></li>
<li><code>spirv-unknown-opengl4.2</code></li>
<li><code>spirv-unknown-opengl4.3</code></li>
<li><code>spirv-unknown-opengl4.5</code></li>
</ul>
<h3 id="opencl-targets"><a class="header" href="#opencl-targets">OpenCL Targets</a></h3>
<ul>
<li><code>spirv-unknown-opencl1.2</code></li>
<li><code>spirv-unknown-opencl1.2embedded</code></li>
<li><code>spirv-unknown-opencl2.0</code></li>
<li><code>spirv-unknown-opencl2.0embedded</code></li>
<li><code>spirv-unknown-opencl2.1</code></li>
<li><code>spirv-unknown-opencl2.1embedded</code></li>
<li><code>spirv-unknown-opencl2.2</code></li>
<li><code>spirv-unknown-opencl2.2embedded</code></li>
</ul>
<h2 id="gpu"><a class="header" href="#gpu">GPU</a></h2>
<p>Currently we don't have specific generations of GPUs for support, as long they support Vulkan 1.1+ with the latest officially installed drivers it should be able build and run the examples. You can check your Vulkan version using the <a href="https://vulkan.lunarg.com/doc/view/latest/windows/vulkaninfo.html"><code>vulkaninfo</code></a> command from the <code>vulkan-sdk</code>.</p>
<h5 id="drivers"><a class="header" href="#drivers">Drivers</a></h5>
<ul>
<li><a href="https://www.amd.com/en/support/kb/faq/gpu-56"><strong>AMD</strong></a></li>
<li><strong>Intel:</strong> <a href="https://www.intel.com/content/www/us/en/support/articles/000005520/graphics.html">Linux</a>, <a href="https://www.intel.com/content/www/us/en/support/articles/000022440/graphics.html">macOS</a>, <a href="https://downloadcenter.intel.com/product/80939/Graphics">Windows</a></li>
<li><a href="https://www.nvidia.com/Download/index.aspx?lang=en-us"><strong>Nvidia</strong></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-shader-crates"><a class="header" href="#writing-shader-crates">Writing Shader Crates</a></h1>
<p>This is section is going to walk you through writing a shader in Rust and
setting up your shader crate.</p>
<p>Be aware that this project is in a very early phase, please <a href="https://github.com/EmbarkStudios/rust-gpu/issues">file an
issue</a> if there's something
not working or unclear.</p>
<h2 id="online"><a class="header" href="#online">Online</a></h2>
<p>You can now test out and try building shaders with rust-gpu from the browser!</p>
<ul>
<li><a href="https://shadered.org/template">SHADERed</a> A shader IDE which has a lite version, which allows you to build
and run shaders on the web.</li>
<li><a href="http://shader-playground.timjones.io/9d744d5893beb6a8f129fda50ad4aeeb">Shader Playground</a> A playground for building and checking the output of
shader code similar to godbolt or play.rust-lang.org.</li>
</ul>
<h2 id="local-setup"><a class="header" href="#local-setup">Local Setup</a></h2>
<p>There are two main ways to setup your shader project locally.</p>
<ol>
<li>Using the <code>spirv-builder</code> crate.
The <code>spirv-builder</code> is a crate designed to automate the process of building
and linking the <code>rust-gpu</code> to be able to compile SPIR-V shaders into your
main Rust crate.</li>
<li>Using <code>.cargo/config</code>.
Alternatively if you're willing to do the setup yourself you can manually set
flags in your cargo configuration to enable you to run <code>cargo build</code> in your
shader crate.</li>
</ol>
<h3 id="using-spirv-builder"><a class="header" href="#using-spirv-builder">Using <code>spirv-builder</code></a></h3>
<p>If you're writing a bigger application and you want to integrate SPIR-V shader
crates to display, it's recommended to use <code>spirv-builder</code> in a build script.</p>
<ol>
<li>Copy the <a href="https://github.com/EmbarkStudios/rust-gpu/blob/main/rust-toolchain.toml"><code>rust-toolchain.toml</code></a> file to your project. (You must use the same
version of Rust as <code>rust-gpu</code>. Utimately, the build will fail with a nice
error message when you don't use the exact same version)</li>
<li>Reference <code>spirv-builder</code> in your Cargo.toml:
<pre><code class="language-toml">[build-dependencies]
spirv-builder = "0.9"
</code></pre>
All dependent crates are published on <a href="https://crates.io">crates.io</a>.</li>
<li>Create a <code>build.rs</code> in your project root.</li>
</ol>
<h4 id="buildrs"><a class="header" href="#buildrs"><code>build.rs</code></a></h4>
<p>Paste the following into <code>build.rs</code></p>
<pre><pre class="playground"><code class="language-rust no_run">use spirv_builder::{MetadataPrintout, SpirvBuilder};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    SpirvBuilder::new(shader_crate, target)
        .print_metadata(MetadataPrintout::Full)
        .build()?;
    Ok(())
}</code></pre></pre>
<p>Substituting <code>shader_crate</code> with a relative path to your shader crate. The values available for the <code>target</code> parameter are available
<a href="./platform-support.html">here</a>.  For example, if building for vulkan 1.1, use
<code>"spirv-unknown-vulkan1.1"</code>.</p>
<p>The <code>SpirvBuilder</code> struct has numerous configuration options available, see
<a href="https://embarkstudios.github.io/rust-gpu/api/spirv_builder/struct.SpirvBuilder.html">documentation</a>.</p>
<h4 id="mainrs"><a class="header" href="#mainrs"><code>main.rs</code></a></h4>
<p>The following will directly include the shader module binary into your application.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SHADER: &amp;[u8] = include_bytes!(env!("&lt;shader_crate&gt;.spv"));
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong> If your shader name contains hyphens, the name of environment variable will be the name with hyphens changed to underscores.</p>
</blockquote>
<p>Keep in mind that by default, build-dependencies are built in debug mode. This
means that the rust-gpu compiler (<code>rustc_codegen_spirv</code>) will be built in debug
mode, and will be <em>incredibly</em> slow. You can solve this by placing this bit of
configuration in your workspace <code>Cargo.toml</code>:</p>
<pre><code class="language-toml"># Compile build-dependencies in release mode with
# the same settings as regular dependencies.
[profile.release.build-override]
opt-level = 3
codegen-units = 16
[profile.dev.build-override]
opt-level = 3
</code></pre>
<p>Keep in mind this will optimize <em>all</em> build script dependencies as release,
which may slow down full rebuilds a bit. Please read <a href="https://github.com/EmbarkStudios/rust-gpu/issues/448">this
issue</a> for more
information, there's a few important caveats to know about this.</p>
<h3 id="using-cargoconfig"><a class="header" href="#using-cargoconfig">Using <code>.cargo/config</code></a></h3>
<blockquote>
<p><strong>Note</strong> This method will require manually rebuilding <code>rust-gpu</code> each
time there has been changes to the repository.</p>
</blockquote>
<p>If you just want to build a shader crate, and don't need to automatically
compile the SPIR-V binary at build time, you can use <code>.cargo/config</code> to set the
necessary flags. Before you can do that however you need to do a couple of steps
first to build the compiler backend.</p>
<ol>
<li>Clone the <code>rust-gpu</code> repository</li>
<li><code>cargo build --release</code> in <code>rust-gpu</code>.</li>
</ol>
<p>Now you should have a <code>librustc_codegen_spirv</code> dynamic library available in
<code>target/release</code>. You'll need to keep this somewhere stable that you can
reference from your shader project.</p>
<p>Now we need to add our <code>.cargo/config</code> file. This is a configuration file that
tells cargo how to build for SPIR-V. You need provide the target you're
compiling for (see <a href="./platform-support.html">platform support</a>) and provide a path
to your built <code>rustc_codegen_spirv</code> dynamic library. We have to also provide
some additional options.</p>
<pre><code class="language-toml">[build]
target = "spirv-unknown-spv1.3"
rustflags = [
    "-Zcodegen-backend=&lt;path_to_librustc_codegen_spirv&gt;",
    "-Zbinary-dep-depinfo",
    "-Csymbol-mangling-version=v0",
    "-Zcrate-attr=feature(register_tool)",
    "-Zcrate-attr=register_tool(rust_gpu)"
]

[unstable]
build-std=["core"]
build-std-features=["compiler-builtins-mem"]
</code></pre>
<p>Now we can build our crate with cargo as normal.</p>
<pre><code class="language-bash">cargo build
</code></pre>
<p>Now you should have <code>&lt;project_name&gt;.spv</code> SPIR-V file in <code>target/debug</code> that you
can give to a renderer.</p>
<h2 id="writing-your-first-shader"><a class="header" href="#writing-your-first-shader">Writing your first shader</a></h2>
<p>Configure your shader crate as a <code>"dylib"</code> type crate, and add <code>spirv-std</code> to its dependencies:</p>
<pre><code class="language-toml">[lib]
crate-type = ["dylib"]

[dependencies]
spirv-std = { version = "0.9" }
</code></pre>
<p>Make sure your shader code uses the <code>no_std</code> attribute and makes the <code>spirv</code> attribute visibile in the global scope. Then, you're ready to write your first shader. Here's a very simple fragment shader called <code>main_fs</code> as an example that outputs the color red:</p>
<pre><pre class="playground"><code class="language-rust norun">#![no_std]

use spirv_std::spirv;
use spirv_std::glam::{vec4, Vec4};

#[spirv(fragment)]
pub fn main_fs(output: &amp;mut Vec4) {
    *output = vec4(1.0, 0.0, 0.0, 1.0);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attribute-syntax"><a class="header" href="#attribute-syntax">Attribute syntax</a></h1>
<p>rust-gpu introduces a number of SPIR-V related attributes to express behavior specific to SPIR-V not exposed in the base rust language.</p>
<p>Before you'll able to use these attributes, make sure you import the attribute from the <code>spirv-std</code> crate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use spirv_std::spirv;
<span class="boring">}</span></code></pre></pre>
<p>There are a few different categories of attributes:</p>
<h2 id="entry-points"><a class="header" href="#entry-points">Entry points</a></h2>
<p>When declaring an entry point to your shader, SPIR-V needs to know what type of function it is. For example, it could be a fragment shader, or vertex shader. Specifying this attribute is also the way rust-gpu knows that you would like to export a function as an entry point, no other functions are exported.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(fragment)]
fn main() { }</code></pre></pre>
<p>Common values are <code>#[spirv(fragment)]</code> and <code>#[spirv(vertex)]</code>. A list of all supported names can be found in <a href="https://docs.rs/spirv_headers/1.5.0/spirv_headers/enum.ExecutionModel.html">spirv_headers</a> - convert the enum name to snake_case for the rust-gpu attribute name.</p>
<h3 id="compute-shader-dimensions"><a class="header" href="#compute-shader-dimensions">Compute shader dimensions</a></h3>
<p>The dimensions (<code>local_size_*</code> in openGL, <code>numthreads</code> in DX) of a compute shader must be specified (eg. <code>#[spirv(compute(threads(32, 16, 97)))]</code>).  Trailing ones may be elided.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// the x dimension is required
// same as threads(32, 1, 1)
#[spirv(compute(threads(32)))]
pub fn compute_1() {}

// same as threads(32, 57, 1)
#[spirv(compute(threads(32, 57)))]
pub fn compute_2() {}
<span class="boring">}</span></code></pre></pre>
<h3 id="override-entry-point-name"><a class="header" href="#override-entry-point-name">Override entry point name</a></h3>
<p>You can override the default <code>OpEntryPoint</code> name for any entry point with the <code>entry_point_name</code> sub-attribute on any of the execution model attributes. (e.g. <code>#[spirv(vertex(entry_point_name="foo"))]</code>)</p>
<h2 id="builtins"><a class="header" href="#builtins">Builtins</a></h2>
<p>When declaring inputs and outputs, sometimes you want to declare it as a "builtin". This means many things, but one example is <code>gl_Position</code> from glsl - the GPU assigns inherent meaning to the variable and uses it for placing the vertex in clip space. The equivalent in rust-gpu is called <code>position</code>.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(vertex)]
fn main(
    #[spirv(position)] out_pos: &amp;mut Vec4,
) { }</code></pre></pre>
<p>Common values are <code>#[spirv(position)]</code>, <code>#[spirv(vertex_id)]</code>, and many more. A list of all supported names can be found in <a href="https://docs.rs/spirv_headers/1.5.0/spirv_headers/enum.BuiltIn.html">spirv_headers</a> - convert the enum name to snake_case for the rust-gpu attribute name.</p>
<h2 id="descriptor-set-and-binding"><a class="header" href="#descriptor-set-and-binding">Descriptor set and binding</a></h2>
<p>A SPIR-V shader must declare where uniform variables are located with explicit indices that match up with CPU-side code. This can be done with the <code>descriptor_set</code> and <code>binding</code> attributes. Note that <code>descriptor_set = 0</code> is reserved for future use, and cannot be used.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(fragment)]
fn main(
    #[spirv(uniform, descriptor_set = 2, binding = 5)] var: &amp;mut Vec4,
) { }</code></pre></pre>
<p>Both descriptor_set and binding take an integer argument that specifies the uniform's index.</p>
<h2 id="flat"><a class="header" href="#flat">Flat</a></h2>
<p>The flat attribute corresponds to the flat keyword in glsl - in other words, the data is not interpolated across the triangle when invoking the fragment shader.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(fragment)]
fn main(#[spirv(flat)] obj: u32) { }</code></pre></pre>
<h2 id="invariant"><a class="header" href="#invariant">Invariant</a></h2>
<p>The invariant attribute corresponds to the invariant keyword in glsl. It can only be applied to output variables.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(vertex)]
fn main(#[spirv(invariant)] var: &amp;mut f32) { }</code></pre></pre>
<h2 id="workgroup-shared-memory"><a class="header" href="#workgroup-shared-memory">Workgroup shared memory</a></h2>
<p>The <code>workgroup</code> attribute defines shared memory, which can be accessed by all invocations within the same workgroup. This corresponds to <code>groupshared</code> memory in hlsl or <code>shared</code> memory in glsl.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(compute(threads(32)))]
fn main(#[spirv(workgroup)] var: &amp;mut [Vec4; 4]) { }</code></pre></pre>
<h2 id="generic-storage-classes"><a class="header" href="#generic-storage-classes">Generic storage classes</a></h2>
<p>The SPIR-V storage class of types is inferred for function signatures. The inference logic can be guided by attributes on the interface specification in the entry points. This also means it needs to be clear from the documentation if an API requires a certain storage class (e.g <code>workgroup</code>) for a variable. Storage class attributes are only permitted on entry points.</p>
<h2 id="specialization-constants"><a class="header" href="#specialization-constants">Specialization constants</a></h2>
<p>Entry point inputs also allow access to <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#SpecializationSection">SPIR-V "specialization constants"</a>,
which are each associated with an user-specified numeric "ID" (SPIR-V <code>SpecId</code>),
used to override them later ("specializing" the shader):</p>
<ul>
<li>in Vulkan: <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap10.html#pipelines-specialization-constants">during pipeline creation, via <code>VkSpecializationInfo</code></a></li>
<li>in WebGPU: <a href="https://www.w3.org/TR/webgpu/#gpuprogrammablestage">during pipeline creation, via <code>GPUProgrammableStage</code><i><code>#constants</code></i></a>
<ul>
<li>note: WebGPU calls them <a href="https://gpuweb.github.io/gpuweb/wgsl/#pipeline-overridable">"pipeline-overridable constants"</a></li>
</ul>
</li>
<li>in OpenCL: <a href="https://registry.khronos.org/OpenCL/sdk/3.0/docs/man/html/clSetProgramSpecializationConstant.html">via <code>clSetProgramSpecializationConstant()</code> calls, before <code>clBuildProgram()</code></a></li>
</ul>
<p>If a "specialization constant" is not overriden, it falls back to its <em>default</em>
value, which is either user-specified (via <code>default = ...</code>), or <code>0</code> otherwise.</p>
<p>While only "specialization constants" of type <code>u32</code> are currently supported, it's
always possible to <em>manually</em> create values of other types, from one or more <code>u32</code>s.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(vertex)]
fn main(
    // Default is implicitly `0`, if not specified.
    #[spirv(spec_constant(id = 1))] no_default: u32,

    // IDs don't need to be sequential or obey any order.
    #[spirv(spec_constant(id = 9000, default = 123))] default_123: u32,

    // Assembling a larger value out of multiple `u32` is also possible.
    #[spirv(spec_constant(id = 100))] x_u64_lo: u32,
    #[spirv(spec_constant(id = 101))] x_u64_hi: u32,
) {
    let x_u64 = ((x_u64_hi as u64) &lt;&lt; 32) | (x_u64_lo as u64);
}</code></pre></pre>
<p><sub><strong>Note</strong>: despite the name "constants", they are <em>runtime values</em> from the
perspective of compiled Rust code (or at most similar to "link-time constants"),
and as such have no connection to <em>Rust constants</em>, especially not Rust type-level
constants and <code>const</code> generics - while specializing some e.g. <code>fn foo&lt;const N: u32&gt;</code>
by <code>N</code> long after it was compiled to SPIR-V, or using "specialization constants"
as Rust array lengths, Rust would sadly require <em>dependent types</em> to type-check
such code (as it would for e.g. expressing C <code>T[n]</code> types with runtime <code>n</code>),
and the main benefit over truly dynamic inputs is a (potential) performance boost.<sub></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-assembly"><a class="header" href="#inline-assembly">Inline Assembly</a></h1>
<p>Rust-GPU has support for inline SPIR-V assembly. In addition the backend
provides several conveniences for writing inline assembly that are documented
below. For more information on specific instruction behaviour and syntax, please
refer to the <a href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html">SPIR-V specification</a>.</p>
<h3 id="basic-syntax--usage"><a class="header" href="#basic-syntax--usage">Basic syntax &amp; usage.</a></h3>
<p>You can write inline assembly using the new <code>asm!</code> macro available with the
<code>asm</code> feature on nightly. Refer to the <a href="https://doc.rust-lang.org/unstable-book/library-features/asm.html">Rust unstable book</a> for more
information on how to use the macro.</p>
<p>Non-ID arguments are written as-is, e.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>asm! {
    "OpCapability DerivativeControl"
}
<span class="boring">}</span></code></pre></pre>
<p>ID based arguments are prefixed with <code>%</code> and their name. <code>Result&lt;id&gt;</code>s accessed
with a <code>=</code> and a ID on the left hand side of the expression. E.g.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vector = spirv_std::glam::Vec2::new(1.0, 0.0);
let mut result = f32::default();

asm! {
    "%vector = OpLoad _ {vector}",
    "%element = OpVectorExtractDynamic _ %vector {index}",
    "OpStore {element} %element",
    vector = in(reg) &amp;vector,
    index = in(reg) index,
    element = in(reg) &amp;mut result
}
<span class="boring">}</span></code></pre></pre>
<p><code>asm!</code> only accepts integers, floats, SIMD vectors, pointers and
function pointers as input variables. However you can have the pointer point
to a generic variable, so you can write generic assembly code like so.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use spirv_std::{scalar::Scalar, vector::Vector};

// This fn is available as `spirv_std::arch::vector_extract_dynamic`
pub unsafe fn vector_extract_dynamic&lt;T: Scalar, V: Vector&lt;T&gt;&gt;(vector: V, index: usize) -&gt; T {
    let mut result = T::default();

    asm! {
        "%vector = OpLoad _ {vector}",
        "%element = OpVectorExtractDynamic _ %vector {index}",
        "OpStore {element} %element",
        vector = in(reg) &amp;vector,
        index = in(reg) index,
        element = in(reg) &amp;mut result
    }

    result
}
<span class="boring">}</span></code></pre></pre>
<h3 id="additional-syntax"><a class="header" href="#additional-syntax">Additional syntax</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody>
<tr><td><code>%&lt;name&gt;</code></td><td>Used to refer to an abstract ID, every unique <code>&lt;name&gt;</code> use generates a new ID.</td></tr>
<tr><td><code>typeof{&lt;variable&gt;}</code></td><td>Returns the type of <code>variable</code></td></tr>
<tr><td><code>_</code> (underscore)</td><td>Equivalent to <code>typeof{&lt;variable&gt;}</code>, but uses inference to determine the variable</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="image-type-syntax"><a class="header" href="#image-type-syntax">Image type syntax</a></h1>
<p>There are a huge number of combinations of image types in SPIR-V. They are represented by a const
generic type called <code>spirv_std::image::Image</code>, however, specifying the generic parameters of this
type is incredibly tedious, so a wrapper macro, <code>spirv_std::Image!</code> can be used to write the type
instead.</p>
<p>The specific syntax and meaning of the arguments to the <code>Image!</code> macro can be found in
<a href="https://embarkstudios.github.io/rust-gpu/api/spirv_std/macro.Image.html">rustdoc</a>.</p>
<p>Some type aliases for common image formats can be found in the
<a href="https://embarkstudios.github.io/rust-gpu/api/spirv_std/image/index.html"><code>spirv_std::image</code></a>
module. For example, <code>Image2d</code> is a very commonly used type, corresponding to <code>texture2D</code> in GLSL,
and is likely what you want if you want a regular old sampled texture.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Image2d = Image!(2D, type=f32, sampled);
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
