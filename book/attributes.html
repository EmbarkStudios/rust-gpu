<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Attribute syntax - Rust GPU Dev Guide</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Contributing to Rust-GPU</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="building-rust-gpu.html"><strong aria-hidden="true">2.1.</strong> Building</a></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">2.2.</strong> Testing</a></li><li class="chapter-item expanded "><a href="codegen-args.html"><strong aria-hidden="true">2.3.</strong> "Codegen args" (flags/options) supported by the Rust-GPU codegen backend</a></li><li class="chapter-item expanded "><a href="spirv-minimization.html"><strong aria-hidden="true">2.4.</strong> Minimizing bugs in SPIR-V</a></li><li class="chapter-item expanded "><a href="publishing-rust-gpu.html"><strong aria-hidden="true">2.5.</strong> Publishing Rust-GPU on crates.io</a></li></ol></li><li class="chapter-item expanded "><a href="platform-support.html"><strong aria-hidden="true">3.</strong> Platform Support</a></li><li class="chapter-item expanded "><a href="writing-shader-crates.html"><strong aria-hidden="true">4.</strong> Writing Shader Crates</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Features</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="attributes.html" class="active"><strong aria-hidden="true">5.1.</strong> Attribute syntax</a></li><li class="chapter-item expanded "><a href="inline-asm.html"><strong aria-hidden="true">5.2.</strong> Inline Assembly</a></li><li class="chapter-item expanded "><a href="image.html"><strong aria-hidden="true">5.3.</strong> Image type syntax</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust GPU Dev Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="attribute-syntax"><a class="header" href="#attribute-syntax">Attribute syntax</a></h1>
<p>rust-gpu introduces a number of SPIR-V related attributes to express behavior specific to SPIR-V not exposed in the base rust language.</p>
<p>Before you'll able to use these attributes, make sure you import the attribute from the <code>spirv-std</code> crate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use spirv_std::spirv;
<span class="boring">}</span></code></pre></pre>
<p>There are a few different categories of attributes:</p>
<h2 id="entry-points"><a class="header" href="#entry-points">Entry points</a></h2>
<p>When declaring an entry point to your shader, SPIR-V needs to know what type of function it is. For example, it could be a fragment shader, or vertex shader. Specifying this attribute is also the way rust-gpu knows that you would like to export a function as an entry point, no other functions are exported.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(fragment)]
fn main() { }</code></pre></pre>
<p>Common values are <code>#[spirv(fragment)]</code> and <code>#[spirv(vertex)]</code>. A list of all supported names can be found in <a href="https://docs.rs/spirv_headers/1.5.0/spirv_headers/enum.ExecutionModel.html">spirv_headers</a> - convert the enum name to snake_case for the rust-gpu attribute name.</p>
<h3 id="compute-shader-dimensions"><a class="header" href="#compute-shader-dimensions">Compute shader dimensions</a></h3>
<p>The dimensions (<code>local_size_*</code> in openGL, <code>numthreads</code> in DX) of a compute shader must be specified (eg. <code>#[spirv(compute(threads(32, 16, 97)))]</code>).  Trailing ones may be elided.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// the x dimension is required
// same as threads(32, 1, 1)
#[spirv(compute(threads(32)))]
pub fn compute_1() {}

// same as threads(32, 57, 1)
#[spirv(compute(threads(32, 57)))]
pub fn compute_2() {}
<span class="boring">}</span></code></pre></pre>
<h3 id="override-entry-point-name"><a class="header" href="#override-entry-point-name">Override entry point name</a></h3>
<p>You can override the default <code>OpEntryPoint</code> name for any entry point with the <code>entry_point_name</code> sub-attribute on any of the execution model attributes. (e.g. <code>#[spirv(vertex(entry_point_name=&quot;foo&quot;))]</code>)</p>
<h2 id="builtins"><a class="header" href="#builtins">Builtins</a></h2>
<p>When declaring inputs and outputs, sometimes you want to declare it as a &quot;builtin&quot;. This means many things, but one example is <code>gl_Position</code> from glsl - the GPU assigns inherent meaning to the variable and uses it for placing the vertex in clip space. The equivalent in rust-gpu is called <code>position</code>.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(vertex)]
fn main(
    #[spirv(position)] out_pos: &amp;mut Vec4,
) { }</code></pre></pre>
<p>Common values are <code>#[spirv(position)]</code>, <code>#[spirv(vertex_id)]</code>, and many more. A list of all supported names can be found in <a href="https://docs.rs/spirv_headers/1.5.0/spirv_headers/enum.BuiltIn.html">spirv_headers</a> - convert the enum name to snake_case for the rust-gpu attribute name.</p>
<h2 id="descriptor-set-and-binding"><a class="header" href="#descriptor-set-and-binding">Descriptor set and binding</a></h2>
<p>A SPIR-V shader must declare where uniform variables are located with explicit indices that match up with CPU-side code. This can be done with the <code>descriptor_set</code> and <code>binding</code> attributes. Note that <code>descriptor_set = 0</code> is reserved for future use, and cannot be used.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(fragment)]
fn main(
    #[spirv(uniform, descriptor_set = 2, binding = 5)] var: &amp;mut Vec4,
) { }</code></pre></pre>
<p>Both descriptor_set and binding take an integer argument that specifies the uniform's index.</p>
<h2 id="flat"><a class="header" href="#flat">Flat</a></h2>
<p>The flat attribute corresponds to the flat keyword in glsl - in other words, the data is not interpolated across the triangle when invoking the fragment shader.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(fragment)]
fn main(#[spirv(flat)] obj: u32) { }</code></pre></pre>
<h2 id="invariant"><a class="header" href="#invariant">Invariant</a></h2>
<p>The invariant attribute corresponds to the invariant keyword in glsl. It can only be applied to output variables.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(vertex)]
fn main(#[spirv(invariant)] var: &amp;mut f32) { }</code></pre></pre>
<h2 id="workgroup-shared-memory"><a class="header" href="#workgroup-shared-memory">Workgroup shared memory</a></h2>
<p>The <code>workgroup</code> attribute defines shared memory, which can be accessed by all invocations within the same workgroup. This corresponds to <code>groupshared</code> memory in hlsl or <code>shared</code> memory in glsl.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(compute(threads(32)))]
fn main(#[spirv(workgroup)] var: &amp;mut [Vec4; 4]) { }</code></pre></pre>
<h2 id="generic-storage-classes"><a class="header" href="#generic-storage-classes">Generic storage classes</a></h2>
<p>The SPIR-V storage class of types is inferred for function signatures. The inference logic can be guided by attributes on the interface specification in the entry points. This also means it needs to be clear from the documentation if an API requires a certain storage class (e.g <code>workgroup</code>) for a variable. Storage class attributes are only permitted on entry points.</p>
<h2 id="specialization-constants"><a class="header" href="#specialization-constants">Specialization constants</a></h2>
<p>Entry point inputs also allow access to <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#SpecializationSection">SPIR-V &quot;specialization constants&quot;</a>,
which are each associated with an user-specified numeric &quot;ID&quot; (SPIR-V <code>SpecId</code>),
used to override them later (&quot;specializing&quot; the shader):</p>
<ul>
<li>in Vulkan: <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap10.html#pipelines-specialization-constants">during pipeline creation, via <code>VkSpecializationInfo</code></a></li>
<li>in WebGPU: <a href="https://www.w3.org/TR/webgpu/#gpuprogrammablestage">during pipeline creation, via <code>GPUProgrammableStage</code><i><code>#constants</code></i></a>
<ul>
<li>note: WebGPU calls them <a href="https://gpuweb.github.io/gpuweb/wgsl/#pipeline-overridable">&quot;pipeline-overridable constants&quot;</a></li>
</ul>
</li>
<li>in OpenCL: <a href="https://registry.khronos.org/OpenCL/sdk/3.0/docs/man/html/clSetProgramSpecializationConstant.html">via <code>clSetProgramSpecializationConstant()</code> calls, before <code>clBuildProgram()</code></a></li>
</ul>
<p>If a &quot;specialization constant&quot; is not overriden, it falls back to its <em>default</em>
value, which is either user-specified (via <code>default = ...</code>), or <code>0</code> otherwise.</p>
<p>While only &quot;specialization constants&quot; of type <code>u32</code> are currently supported, it's
always possible to <em>manually</em> create values of other types, from one or more <code>u32</code>s.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">#[spirv(vertex)]
fn main(
    // Default is implicitly `0`, if not specified.
    #[spirv(spec_constant(id = 1))] no_default: u32,

    // IDs don't need to be sequential or obey any order.
    #[spirv(spec_constant(id = 9000, default = 123))] default_123: u32,

    // Assembling a larger value out of multiple `u32` is also possible.
    #[spirv(spec_constant(id = 100))] x_u64_lo: u32,
    #[spirv(spec_constant(id = 101))] x_u64_hi: u32,
) {
    let x_u64 = ((x_u64_hi as u64) &lt;&lt; 32) | (x_u64_lo as u64);
}</code></pre></pre>
<p><sub><strong>Note</strong>: despite the name &quot;constants&quot;, they are <em>runtime values</em> from the
perspective of compiled Rust code (or at most similar to &quot;link-time constants&quot;),
and as such have no connection to <em>Rust constants</em>, especially not Rust type-level
constants and <code>const</code> generics - while specializing some e.g. <code>fn foo&lt;const N: u32&gt;</code>
by <code>N</code> long after it was compiled to SPIR-V, or using &quot;specialization constants&quot;
as Rust array lengths, Rust would sadly require <em>dependent types</em> to type-check
such code (as it would for e.g. expressing C <code>T[n]</code> types with runtime <code>n</code>),
and the main benefit over truly dynamic inputs is a (potential) performance boost.<sub></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="writing-shader-crates.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="inline-asm.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="writing-shader-crates.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="inline-asm.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
